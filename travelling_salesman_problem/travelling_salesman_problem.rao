import java.util.ArrayList

constant количество_Городов = 15;
constant ширина_поля = 50;
constant высота_поля = 50;

constant размер_популяции = 100;
constant количество_особей_на_мутацию = 50;
constant количество_генов = количество_Городов - (количество_Городов % 2);
constant количество_генов_на_мутацию = Math.floor(количество_генов * 0.4);
constant количество_особей_на_скрещивание = размер_популяции - количество_особей_на_мутацию;
constant количество_точек_скрещивания = 3;

enum выбор {Y, N}
enum отрисовка {Y, N}
enum мутация {Y, N}
enum скрещивание {Y, N}
enum отбор {Y, N}

enum фазы {фаза_мутации, фаза_скрещивания, фаза_отбора}

type Переменная_состояния {
	фазы текущая_фаза;
}

resource глобальная_переменная_состояния = Переменная_состояния.create(фазы.фаза_мутации);

type Города {
	выбор флаг_выбора;
	отрисовка флаг_отрисовки;
	double x;
	double y;
}

type Маршрут {
	ArrayList<Города> маршрут;
	double длина_маршрута;
}

type Особи {
	ArrayList<Double> пары_меняющихся_узлов;
	ArrayList<Города> маршрут;
	double длина_маршрута;
	double поколение;
	мутация флаг_мутации;
	скрещивание флаг_скрещивания;
	отбор флаг_отбора;
}

sequence последовательность_координат_ширины = new Uniform(123456789, 0, ширина_поля);
sequence последовательность_координат_высоты = new Uniform(9, 0, высота_поля);
sequence последовательность_индексов_городов = new Uniform(123456, 0, количество_Городов);
sequence последовательность_индексов_генов = new Uniform(34, 0, количество_генов);

resource маршрут_методом_жадного_алгоритма = Маршрут.create(new ArrayList<Города>(), 0);

def init(){
	for (var i = 0; i < количество_Городов; i++) {
		Города.create(выбор.N, отрисовка.N, последовательность_координат_ширины.next(),
			последовательность_координат_высоты.next());
	}
	Жадный_алгоритм(маршрут_методом_жадного_алгоритма);
	Создание_популяции();
	Эволюция.plan(1);
}

void Жадный_алгоритм (Маршрут путь_к_ближайшему){
	var текущий = Города.all.any;
	путь_к_ближайшему.маршрут.add(текущий);
	текущий.флаг_выбора = выбор.Y;

	for (var Города следующий; Города.all.filter[флаг_выбора == выбор.N].size() > 0;) {

		val X = текущий.x;
		val Y = текущий.y;

		следующий = Города.all.filter[флаг_выбора == выбор.N].minBySafe[расстояние_между_точками(X, Y, x, y)];

		путь_к_ближайшему.маршрут.add(следующий);
		следующий.флаг_выбора = выбор.Y;
		текущий = следующий;
	}
	путь_к_ближайшему.длина_маршрута = Подсчёт_длины_маршрута(путь_к_ближайшему.маршрут);
	Сброс_флага_выбора()
}

void Сброс_флага_выбора(){
	for (; Города.all.filter[флаг_выбора == выбор.Y].size() > 0;) {
		var Города Город = Города.all.filter[флаг_выбора == выбор.Y].any;
		Город.флаг_выбора = выбор.N
	}
}

void Создание_популяции(){
	for (var i = 0; i < размер_популяции; i++) {
		var Odin = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), 0, 0, мутация.N, скрещивание.N,
			отбор.N)
		for (var j = 0; j < количество_генов; j++) {
			Odin.пары_меняющихся_узлов.add(Math.floor(последовательность_индексов_городов.next()) as Double);
		}
		Odin.маршрут = Преобразовать_в_маршрут(Odin.пары_меняющихся_узлов);
		Odin.длина_маршрута = Подсчёт_длины_маршрута(Odin.маршрут);
	}
}

type Массив_длин_маршрутов {
	ArrayList<Double> Длины_маршрутов;
}
resource массив_лучших = Массив_длин_маршрутов.create(new ArrayList<Double>());
resource массив_худших = Массив_длин_маршрутов.create(new ArrayList<Double>());

event Эволюция(){
	Сброс_флагов_особей();
	Мутация();
	Скрещивание();
	Отбор();
	Эволюция.plan(currentTime + 1);
	массив_лучших._Длины_маршрутов.add(Лучшая_особь());
	массив_худших._Длины_маршрутов.add(Худшая_особь());
}

void Мутация() {
	for (var i = 0; i < количество_особей_на_мутацию && Особи.all.filter [
		флаг_скрещивания == скрещивание.N && флаг_мутации == мутация.N
	].size() > 0; i++) {

		var Особи grip = Особи.all.filter[флаг_скрещивания == скрещивание.N && флаг_мутации == мутация.N].any;
		var Особи ebola = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), grip.длина_маршрута, 0,
			мутация.N, скрещивание.N, отбор.N);
		for (var j = 0; j < grip.пары_меняющихся_узлов.size(); j++) {
			ebola.пары_меняющихся_узлов.add(grip.пары_меняющихся_узлов.get(j));
		}
		for (var j = 0; j < количество_генов_на_мутацию; j++) {
			ebola.пары_меняющихся_узлов.set(intValue(Math.floor(последовательность_индексов_генов.next())),
				Math.floor(последовательность_индексов_городов.next()) as Double);
		}
		grip.флаг_мутации = мутация.Y;
		ebola.флаг_мутации = мутация.Y;
		ebola.поколение = grip.поколение + 1;
		ebola.маршрут = Преобразовать_в_маршрут(ebola.пары_меняющихся_узлов);
		ebola.длина_маршрута = Подсчёт_длины_маршрута(ebola.маршрут);
	}
}

void Скрещивание() {
	for (var i = 0; i < Math.floor(количество_особей_на_скрещивание / 2) && Особи.accessible.filter [
		флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N
	].size() > 2; i++) {
		var Особи адам = Особи.accessible.filter[флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N].any;
		var Особи ева = Особи.accessible.filter[флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N].any;
		адам.флаг_скрещивания = скрещивание.Y;
		ева.флаг_скрещивания = скрещивание.Y;
		var avel = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), адам.длина_маршрута,
			адам.поколение + 1, мутация.N, скрещивание.N, отбор.N);
		var Особи kain = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), ева.длина_маршрута,
			ева.поколение + 1, мутация.N, скрещивание.N, отбор.N);

		for (var j = 0; j < адам.пары_меняющихся_узлов.size(); j++) {
			avel.пары_меняющихся_узлов.add(адам.пары_меняющихся_узлов.get(j));
		}

		for (var j = 0; j < ева.пары_меняющихся_узлов.size(); j++) {
			kain.пары_меняющихся_узлов.add(ева.пары_меняющихся_узлов.get(j));
		}

		var ArrayList<Double> temp = new ArrayList<Double>();

		for (var j = 0; j < ева.пары_меняющихся_узлов.size(); j++) {
			temp.add(ева.пары_меняющихся_узлов.get(j));
		}

		for (var j = 0; j < количество_точек_скрещивания; j++) {
			var точка_скрещивания = Math.floor(последовательность_индексов_генов.next());
			for (var int k = intValue(точка_скрещивания); k < avel.пары_меняющихся_узлов.size(); k++) {
				temp.set(k, avel.пары_меняющихся_узлов.get(k));
				avel.пары_меняющихся_узлов.set(k, kain.пары_меняющихся_узлов.get(k))
				kain.пары_меняющихся_узлов.set(k, temp.get(k));
			}
		}

		avel.поколение = адам.поколение + 1;
		avel.флаг_скрещивания = скрещивание.Y;
		avel.маршрут = Преобразовать_в_маршрут(avel.пары_меняющихся_узлов);
		avel.длина_маршрута = Подсчёт_длины_маршрута(avel.маршрут);

		kain.поколение = ева.поколение + 1;
		kain.флаг_скрещивания = скрещивание.Y;
		kain.маршрут = Преобразовать_в_маршрут(kain.пары_меняющихся_узлов);
		kain.длина_маршрута = Подсчёт_длины_маршрута(kain.маршрут);
	}
}
void Отбор() {
	for (; Особи.all.size() > размер_популяции && Особи.accessible.filter[флаг_отбора == отбор.N].size() > 2;) {
		var Особи kenny1 = Особи.accessible.filter[флаг_отбора == отбор.N].maxBySafe[длина_маршрута];
		var Особи kenny2 = Особи.accessible.filter[флаг_отбора == отбор.N].maxBySafe[длина_маршрута];
		if (kenny1.длина_маршрута > kenny2.длина_маршрута) {
			kenny1.erase();
			kenny2.флаг_отбора = отбор.Y;
		} else {
			kenny2.erase();
			kenny1.флаг_отбора = отбор.Y;
		}

		if (Особи.accessible.filter[флаг_отбора == отбор.N].size() < 2) {
			for (; Особи.all.size() > размер_популяции;) {
				var Kenny = Особи.all.maxBySafe[длина_маршрута];
				Kenny.erase();
			}
		}
	}
}

void Сброс_флагов_особей(){
	for (; Особи.all.filter[флаг_мутации == мутация.Y].size() > 0;) {
		var особь = Особи.all.filter[флаг_мутации == мутация.Y].any
		особь.флаг_мутации = мутация.N;
	}
	for (; Особи.all.filter[флаг_скрещивания == скрещивание.Y].size() > 0;) {
		var особь = Особи.all.filter[флаг_скрещивания == скрещивание.Y].any
		особь.флаг_скрещивания = скрещивание.N;
	}
	for (; Особи.all.filter[флаг_отбора == отбор.Y].size() > 0;) {
		var особь = Особи.all.filter[флаг_отбора == отбор.Y].any
		особь.флаг_отбора = отбор.N;
	}
}

ArrayList<Города> Преобразовать_в_маршрут(ArrayList<Double> пары_меняющихся_узлов){
	var ArrayList<Города> маршрут = new ArrayList<Города>();

	for (; Города.all.filter[флаг_выбора == выбор.N].size() > 0;) {
		var избранный = Города.all.filter[флаг_выбора == выбор.N].any;
		маршрут.add(избранный);
		избранный.флаг_выбора = выбор.Y;
	}
	Сброс_флага_выбора();
	for (var i = 0; i < пары_меняющихся_узлов.size() - 1; i = i + 2) {
		маршрут = Поменять_точки(маршрут, intValue(пары_меняющихся_узлов.get(i)),
			intValue(пары_меняющихся_узлов.get(i + 1)));
	}
	return маршрут;
}

ArrayList<Города> Поменять_точки(ArrayList<Города> маршрут, int p1, int p2){
	var Города temp = маршрут.get(p1);
	маршрут.set(p1, маршрут.get(p2));
	маршрут.set(p2, temp);
	return маршрут;
}

int intValue(Double D){
	var double d = Double.valueOf(D);
	var int i = d as int;
	return i;
}

double расстояние_между_точками(double x1, double y1, double x2, double y2){
	val y_diff = Math.abs(y1 - y2)
	val x_diff = Math.abs(x1 - x2)
	return Math.sqrt(y_diff * y_diff + x_diff * x_diff)
}

double Подсчёт_длины_маршрута(ArrayList<Города> маршрут) {
	if (маршрут.size() <= 1)
		return 0;
	var Города исходный = маршрут.get(0);
	var Города текущий = исходный;
	var double общая_длина_пути = 0;

	for (var i = 1; i < маршрут.size(); i++) {
		var Города следующий = маршрут.get(i);
		общая_длина_пути = общая_длина_пути + расстояние_между_точками(текущий.x, текущий.y, следующий.x, следующий.y);
		текущий = следующий;
	}
	общая_длина_пути = общая_длина_пути + расстояние_между_точками(текущий.x, текущий.y, исходный.x, исходный.y);
	return общая_длина_пути;
}

constant A = 600;
constant B = 400;
constant рамка = 25;
constant шаг_отрисовки_графика = 1;
constant отступ_текста = 2;

Double Лучшая_особь(){
	val Особи особь = Особи.accessible.minBySafe[длина_маршрута]
	return особь.длина_маршрута;
}

Double Худшая_особь(){
	val Особи Особь = Особи.accessible.maxBySafe[длина_маршрута]
	return Особь.длина_маршрута;
}

int Значение_шага_отрисовки(int value){
	if (value < 10) {
		return 1;
	}
	return value / 10;
}

String toString(int value){
	return Integer.toString(value);
}

frame GraphOfЭволюция {
	def init(){
		background = new Background(A + 2 * рамка, B + 2 * рамка, RaoColor.WHITE);
	}

	def draw(){
		var верхняя_точка_графика = массив_лучших._Длины_маршрутов.get(0);

		var шаг_отрисовки = Значение_шага_отрисовки(массив_лучших._Длины_маршрутов.size());

		val протяжённость_маршрута_по_методу_жадного_алгоритма = маршрут_методом_жадного_алгоритма.длина_маршрута;
		drawLine(рамка, рамка, рамка, B + рамка, RaoColor.BLACK);
		drawLine(рамка, B + рамка, A + рамка, B + рамка, RaoColor.BLACK);
		drawLine(рамка,
			рамка + B - (протяжённость_маршрута_по_методу_жадного_алгоритма * B / верхняя_точка_графика) as int,
			рамка + A,
			рамка + B - (протяжённость_маршрута_по_методу_жадного_алгоритма * B / верхняя_точка_графика) as int,
			RaoColor.GREEN);
		drawText(toString(протяжённость_маршрута_по_методу_жадного_алгоритма as int), рамка + отступ_текста,
			B - (протяжённость_маршрута_по_методу_жадного_алгоритма * B / верхняя_точка_графика) as int + отступ_текста)
		if (массив_лучших._Длины_маршрутов.size() >= 2 * шаг_отрисовки) {
			for (var i = 0; i < массив_лучших._Длины_маршрутов.size() - шаг_отрисовки; i += шаг_отрисовки) {
				drawText(toString(intValue(массив_лучших._Длины_маршрутов.get(i))),
					рамка + A * (i) / (массив_лучших._Длины_маршрутов.size()) + отступ_текста,
					рамка + B - (intValue(массив_лучших._Длины_маршрутов.get(i)) * B / верхняя_точка_графика) as int +
						отступ_текста)
						drawCircle(рамка + A * i / (массив_лучших._Длины_маршрутов.size()), рамка + B -
							(intValue(массив_лучших._Длины_маршрутов.get(i)) * B / верхняя_точка_графика) as int, 3)

						drawText(toString(i), рамка + (A * i / массив_лучших._Длины_маршрутов.size()) + отступ_текста,
							рамка + B + отступ_текста)
						drawCircle(рамка + (A * i / массив_лучших._Длины_маршрутов.size()), рамка + B, 3)
					}
				}
				if (массив_лучших._Длины_маршрутов.size() >= 2 * шаг_отрисовки_графика) {
					for (var i = 0; i < массив_лучших._Длины_маршрутов.size() - шаг_отрисовки_графика; i +=
						шаг_отрисовки_графика) {
						drawLine(рамка + (A * i / массив_лучших._Длины_маршрутов.size()), рамка + B -
							(intValue(массив_лучших._Длины_маршрутов.get(i)) * B / верхняя_точка_графика) as int,
							рамка + (A * (i + шаг_отрисовки_графика) / массив_лучших._Длины_маршрутов.size()),
							рамка + B - (intValue(массив_лучших._Длины_маршрутов.get(i + шаг_отрисовки_графика)) * B /
								верхняя_точка_графика) as int, RaoColor.RED);
					}
				}
			}
		}
		void Сброс_флага_выбораDraw(){
			for (; Города.all.filter[флаг_отрисовки == отрисовка.Y].size() > 0;) {
				var Города город = Города.all.filter[флаг_отрисовки == отрисовка.Y].any;
				город.флаг_отрисовки = отрисовка.N
			}
		}

		frame Маршрут_лучшей_особи {
			def init(){
				background = new Background(A + 2 * рамка, B + 2 * рамка, RaoColor.WHITE);
			}

			def draw(){
				for (; Города.all.filter[флаг_отрисовки == отрисовка.N].size() > 0;) {
					val current = Города.accessible.filter[флаг_отрисовки == отрисовка.N].any;
					drawCircle(intValue(рамка + current.x * A / ширина_поля),
						intValue(рамка + current.y * B / высота_поля), 3);
					current.флаг_отрисовки = отрисовка.Y
				}
				Сброс_флага_выбораDraw();
				val Особи особь = Особи.accessible.minBySafe[длина_маршрута];
				if (особь.маршрут.size() <= 1) {
					return;
				}
				log(особь.маршрут.size())
				for (var i = 0; i < особь.маршрут.size() - 1; i++) {
					val current = особь.маршрут.get(i);
					val next = особь.маршрут.get(i + 1);
					drawLine(intValue(рамка + current.x * A / ширина_поля),
						intValue(рамка + current.y * B / высота_поля), intValue(рамка + next.x * A / ширина_поля),
						intValue(рамка + next.y * B / высота_поля), RaoColor.RED);
				}
				val current = особь.маршрут.get(особь.маршрут.size() - 1);
				val next = особь.маршрут.get(0);
				drawLine(intValue(рамка + current.x * A / ширина_поля), intValue(рамка + current.y * B / высота_поля),
					intValue(рамка + next.x * A / ширина_поля), intValue(рамка + next.y * B / высота_поля),
					RaoColor.RED);
				}
			}

			frame Маршрут_методом_жадного_алгоритма {
				def init(){
					background = new Background(A + 2 * рамка, B + 2 * рамка, RaoColor.WHITE);
				}

				def draw(){
					for (; Города.all.filter[флаг_отрисовки == отрисовка.N].size() > 0;) {
						val Города current = Города.accessible.filter[флаг_отрисовки == отрисовка.N].any;
						drawCircle(intValue(рамка + current.x * A / ширина_поля),
							intValue(рамка + current.y * B / высота_поля), 3);
						current.флаг_отрисовки = отрисовка.Y
					}
					Сброс_флага_выбораDraw();
					if (маршрут_методом_жадного_алгоритма.маршрут.size() <= 1) {
						return;
					}
					for (var i = 0; i < маршрут_методом_жадного_алгоритма.маршрут.size() - 1; i++) {
						val current = маршрут_методом_жадного_алгоритма.маршрут.get(i);
						val next = маршрут_методом_жадного_алгоритма.маршрут.get(i + 1);
						drawLine(intValue(рамка + current.x * A / ширина_поля),
							intValue(рамка + current.y * B / высота_поля), intValue(рамка + next.x * A / ширина_поля),
							intValue(рамка + next.y * B / высота_поля), RaoColor.GREEN);
					}
					val current = маршрут_методом_жадного_алгоритма.маршрут.get(
						маршрут_методом_жадного_алгоритма.маршрут.size() - 1);
					val next = маршрут_методом_жадного_алгоритма.маршрут.get(0);
					drawLine(intValue(рамка + current.x * A / ширина_поля),
						intValue(рамка + current.y * B / высота_поля), intValue(рамка + next.x * A / ширина_поля),
						intValue(рамка + next.y * B / высота_поля), RaoColor.GREEN);
				}
			}
			