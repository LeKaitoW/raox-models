import java.util.ArrayList

constant количество_городов = 15
constant ширина_поля = 50
constant высота_поля = 50

constant размер_популяции = 100
constant количество_особей_на_мутацию = 50
constant количество_генов = количество_городов - (количество_городов % 2)
constant количество_генов_на_мутацию = Math.floor(количество_генов * 0.1)
constant количество_особей_на_скрещивание = размер_популяции - количество_особей_на_мутацию
constant количество_точек_скрещивания = 3

enum выбор {Y, N}
enum мутация {Y, N}
enum скрещивание {Y, N}
enum отбор {Y, N}

type Особи {
	ArrayList<Double> пары_меняющихся_узлов
	ArrayList<Города> маршрут
	double длина_маршрута
	double поколение
	мутация флаг_мутации
	скрещивание флаг_скрещивания
	отбор флаг_отбора
}

sequence последовательность_координат_ширины = new Uniform(123456789, 0, ширина_поля)
sequence последовательность_координат_высоты = new Uniform(9, 0, высота_поля)
sequence последовательность_индексов_городов = new Uniform(123456, 0, количество_городов)
sequence последовательность_индексов_генов = new Uniform(34, 0, количество_генов)

resource маршрут_методом_жадного_алгоритма = Маршрут.create(new ArrayList<Города>(), 0)

def init(){
	for (var i = 1; i <= количество_городов; i++) {
		Города.create(i, выбор.N, frame_a_graph_of_evolution.отрисовка.N, последовательность_координат_ширины.next(),
			последовательность_координат_высоты.next())
	}
	Жадный_алгоритм(маршрут_методом_жадного_алгоритма)
	Создание_популяции()
	Эволюция.plan(1)
}

type Города {
	int номер
	выбор флаг_выбора
	frame_a_graph_of_evolution.отрисовка флаг_отрисовки
	double x
	double y
}

String toString (int value){
	return Integer.toString(value)

}

type Маршрут {
	ArrayList<Города> маршрут
	double длина_маршрута
}

void Жадный_алгоритм (Маршрут путь_к_ближайшему){
	var текущий = Города.all.any
	путь_к_ближайшему.маршрут.add(текущий)
	текущий.флаг_выбора = выбор.Y

	for (var Города следующий; Города.all.filter[флаг_выбора == выбор.N].size() > 0;) {

		val X = текущий.x
		val Y = текущий.y

		следующий = Города.all.filter[флаг_выбора == выбор.N].minBySafe[Расстояние_между_точками(X, Y, x, y)]

		путь_к_ближайшему.маршрут.add(следующий)
		следующий.флаг_выбора = выбор.Y
		текущий = следующий
	}
	путь_к_ближайшему.длина_маршрута = Подсчёт_длины_маршрута(путь_к_ближайшему.маршрут)
	Сброс_флага_выбора()
}

void Сброс_флага_выбора(){
	for (город : Города.all.filter[флаг_выбора == выбор.Y]) {
		город.флаг_выбора = выбор.N
	}
}

void Создание_популяции(){
	for (var i = 0; i < размер_популяции; i++) {
		var особь = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), 0, 0, мутация.N, скрещивание.N,
			отбор.N)
		for (var j = 0; j < количество_генов; j++) {
			особь.пары_меняющихся_узлов.add(Math.floor(последовательность_индексов_городов.next()) as Double)
		}
		особь.маршрут = Преобразовать_в_маршрут(особь.пары_меняющихся_узлов)
		особь.длина_маршрута = Подсчёт_длины_маршрута(особь.маршрут)
	}
}

type Массив_длин_маршрутов {
	ArrayList<Double> длины_маршрутов
}

resource массив_лучших = Массив_длин_маршрутов.create(new ArrayList<Double>())
resource массив_худших = Массив_длин_маршрутов.create(new ArrayList<Double>())

event Эволюция(){
	Сброс_флагов_особей()
	Скрещивание()
	Мутация()
	Отбор()
	Эволюция.plan(currentTime + 1)
	массив_лучших.длины_маршрутов.add(Кратчайший_путь())
}

void Мутация() {
	var количество_мутировавших_особей = 0
	for (мутирующая_особь : Особи.all.filter[флаг_скрещивания == скрещивание.N && флаг_мутации == мутация.N]) {
		if (количество_мутировавших_особей > количество_особей_на_мутацию)
			return;
		количество_мутировавших_особей = количество_мутировавших_особей + 1
		var Особи мутировавшая_особь = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			мутирующая_особь.длина_маршрута, 0, мутация.N, скрещивание.N, отбор.N)
		for (ген : мутирующая_особь.пары_меняющихся_узлов) {
			мутировавшая_особь.пары_меняющихся_узлов.add(ген)
		}
		for (var j = 0; j < количество_генов_на_мутацию; j++) {
			мутировавшая_особь.пары_меняющихся_узлов.set(Math.floor(последовательность_индексов_генов.next()) as int,
				Math.floor(последовательность_индексов_городов.next()) as Double)
		}
		мутирующая_особь.флаг_мутации = мутация.Y
		мутировавшая_особь.флаг_мутации = мутация.Y
		мутировавшая_особь.поколение = мутирующая_особь.поколение + 1
		мутировавшая_особь.маршрут = Преобразовать_в_маршрут(мутировавшая_особь.пары_меняющихся_узлов)
		мутировавшая_особь.длина_маршрута = Подсчёт_длины_маршрута(мутировавшая_особь.маршрут)
	}
}

void Скрещивание() {
	for (var i = 0; i < Math.floor(количество_особей_на_скрещивание / 2) && Особи.accessible.filter [
		флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N
	].size() > 2; i++) {
		var Особи особь_предок_1 = Особи.accessible.filter [
			флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N
		].maxBySafe[длина_маршрута]
		особь_предок_1.флаг_скрещивания = скрещивание.Y
		var Особи особь_предок_2 = Особи.accessible.filter [
			флаг_мутации == мутация.N && флаг_скрещивания == скрещивание.N
		].maxBySafe[длина_маршрута]
		особь_предок_2.флаг_скрещивания = скрещивание.Y
		var особь_потомок_1 = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			особь_предок_1.длина_маршрута, особь_предок_1.поколение + 1, мутация.N, скрещивание.N, отбор.N)
		var Особи особь_потомок_2 = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			особь_предок_2.длина_маршрута, особь_предок_2.поколение + 1, мутация.N, скрещивание.N, отбор.N)

		for (ген : особь_предок_1.пары_меняющихся_узлов) {
			особь_потомок_1.пары_меняющихся_узлов.add(ген)
		}

		for (ген : особь_предок_2.пары_меняющихся_узлов) {
			особь_потомок_2.пары_меняющихся_узлов.add(ген)
		}

		var ArrayList<Double> temp = new ArrayList<Double>()

		for (ген : особь_предок_2.пары_меняющихся_узлов) {
			temp.add(ген)
		}

		for (var j = 0; j < количество_точек_скрещивания; j++) {
			var точка_скрещивания = Math.floor(последовательность_индексов_генов.next())
			for (var int k = точка_скрещивания as int; k < особь_потомок_1.пары_меняющихся_узлов.size(); k++) {
				temp.set(k, особь_потомок_1.пары_меняющихся_узлов.get(k))
				особь_потомок_1.пары_меняющихся_узлов.set(k, особь_потомок_2.пары_меняющихся_узлов.get(k))
				особь_потомок_2.пары_меняющихся_узлов.set(k, temp.get(k))
			}
		}

		особь_потомок_1.поколение = особь_предок_1.поколение + 1
		особь_потомок_1.флаг_скрещивания = скрещивание.Y
		особь_потомок_1.маршрут = Преобразовать_в_маршрут(особь_потомок_1.пары_меняющихся_узлов)
		особь_потомок_1.длина_маршрута = Подсчёт_длины_маршрута(особь_потомок_1.маршрут)

		особь_потомок_2.поколение = особь_предок_2.поколение + 1
		особь_потомок_2.флаг_скрещивания = скрещивание.Y
		особь_потомок_2.маршрут = Преобразовать_в_маршрут(особь_потомок_2.пары_меняющихся_узлов)
		особь_потомок_2.длина_маршрута = Подсчёт_длины_маршрута(особь_потомок_2.маршрут)
	}
}

void Отбор() {
	for (; Особи.all.size() > размер_популяции && Особи.accessible.filter[флаг_отбора == отбор.N].size() > 2;) {
		var Особи особь_1 = Особи.accessible.filter[флаг_отбора == отбор.N].any
		особь_1.флаг_отбора = отбор.Y
		var Особи особь_2 = Особи.accessible.filter[флаг_отбора == отбор.N].any
		особь_2.флаг_отбора = отбор.Y
		if (особь_1.длина_маршрута > особь_2.длина_маршрута) {
			особь_1.erase()
		} else {
			особь_2.erase()
		}

		if (Особи.accessible.filter[флаг_отбора == отбор.N].size() < 2) {
			for (; Особи.all.size() > размер_популяции;) {
				var особь = Особи.all.maxBySafe[длина_маршрута]
				особь.erase()
			}
		}
	}
}

void Сброс_флагов_особей(){
	for (особь : Особи.all.filter[флаг_мутации == мутация.Y]) {
		особь.флаг_мутации = мутация.N
	}
	for (особь : Особи.all.filter[флаг_скрещивания == скрещивание.Y]) {
		особь.флаг_скрещивания = скрещивание.N
	}
	for (особь : Особи.all.filter[флаг_отбора == отбор.Y]) {
		особь.флаг_отбора = отбор.N
	}
}

ArrayList<Города> Преобразовать_в_маршрут(ArrayList<Double> пары_меняющихся_узлов){
	var ArrayList<Города> маршрут = new ArrayList<Города>()

	for (избранный : Города.all.filter[флаг_выбора == выбор.N]) {
		маршрут.add(избранный)
		избранный.флаг_выбора = выбор.Y
	}
	Сброс_флага_выбора()
	for (var i = 0; i < пары_меняющихся_узлов.size() - 1; i = i + 2) {
		маршрут = Поменять_местами_элементы_в_массиве(маршрут, intValue(пары_меняющихся_узлов.get(i)),
			intValue(пары_меняющихся_узлов.get(i + 1)))
	}
	return маршрут
}

ArrayList<Города> Поменять_местами_элементы_в_массиве(ArrayList<Города> маршрут, int p1, int p2){
	var Города temp = маршрут.get(p1)
	маршрут.set(p1, маршрут.get(p2))
	маршрут.set(p2, temp)
	return маршрут
}

int intValue(Double D){
	var double d = Double.valueOf(D)
	var int i = d as int
	return i
}

double Расстояние_между_точками(double x1, double y1, double x2, double y2){
	val y_diff = Math.abs(y1 - y2)
	val x_diff = Math.abs(x1 - x2)
	return Math.sqrt(y_diff * y_diff + x_diff * x_diff)
}

double Подсчёт_длины_маршрута(ArrayList<Города> маршрут) {
	if (маршрут.size() <= 1)
		return 0
	var Города исходный = маршрут.get(0)
	var Города текущий = исходный
	var double общая_длина_пути = 0

	for (var i = 1; i < маршрут.size(); i++) {
		var Города следующий = маршрут.get(i)
		общая_длина_пути = общая_длина_пути + Расстояние_между_точками(текущий.x, текущий.y, следующий.x, следующий.y)
		текущий = следующий
	}
	общая_длина_пути = общая_длина_пути + Расстояние_между_точками(текущий.x, текущий.y, исходный.x, исходный.y)
	return общая_длина_пути
}

Double Кратчайший_путь(){
	return Особи.accessible.minBySafe[длина_маршрута].длина_маршрута
}

result пробег = new Result([Кратчайший_путь()])
