import java.util.ArrayList

constant количество_городов = 15
constant ширина_поля = 50
constant высота_поля = 50

constant размер_популяции = 100
constant количество_особей_на_мутацию = 50
constant количество_генов = количество_городов - (количество_городов % 2)
constant количество_генов_на_мутацию = Math.floor(количество_генов * 0.1)
constant количество_особей_на_скрещивание = размер_популяции - количество_особей_на_мутацию
constant количество_точек_скрещивания = 3
constant количество_поколений_для_условия_остановки = 10000

type Особи {
	ArrayList<Double> пары_меняющихся_узлов
	ArrayList<Города> маршрут
	double длина_маршрута
	double поколение
	boolean флаг_мутации
	boolean флаг_скрещивания
	boolean флаг_отбора
}

sequence последовательность_координат_ширины = new Uniform(123456789, 0, ширина_поля)
sequence последовательность_координат_высоты = new Uniform(642466339, 0, высота_поля)
sequence последовательность_индексов_городов = new Uniform(126743456, 0, количество_городов)
sequence последовательность_индексов_генов = new Uniform(345345672, 0, количество_генов)

resource маршрут_методом_жадного_алгоритма = Маршрут.create(new ArrayList<Города>(), 0)

def init(){
	for (var i = 1; i <= количество_городов; i++) {
		Города.create(i, false, false, последовательность_координат_ширины.next(),
			последовательность_координат_высоты.next())
	}
	жадный_алгоритм(маршрут_методом_жадного_алгоритма)
	создание_популяции()
	Эволюция.plan(1)
}

type Города {
	int номер
	boolean флаг_выбора
	boolean флаг_отрисовки
	double x
	double y
}

String toString (int value){
	return Integer.toString(value)

}

type Маршрут {
	ArrayList<Города> маршрут
	double длина_маршрута
}

void жадный_алгоритм (Маршрут путь_к_ближайшему){
	var текущий = Города.all.any
	путь_к_ближайшему.маршрут.add(текущий)
	текущий.флаг_выбора = true

	for (var Города следующий; Города.all.filter[флаг_выбора == false].size() > 0;) {

		val X = текущий.x
		val Y = текущий.y

		следующий = Города.all.filter[флаг_выбора == false].minBySafe[расстояние_между_точками(X, Y, x, y)]

		путь_к_ближайшему.маршрут.add(следующий)
		следующий.флаг_выбора = true
		текущий = следующий
	}
	путь_к_ближайшему.длина_маршрута = подсчёт_длины_маршрута(путь_к_ближайшему.маршрут)
	сброс_флага_выбора()
}

void сброс_флага_выбора(){
	for (город : Города.all.filter[флаг_выбора == true]) {
		город.флаг_выбора = false
	}
}

void создание_популяции(){
	for (var i = 0; i < размер_популяции; i++) {
		var особь = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(), 0, 0, false, false, false)
		for (var j = 0; j < количество_генов; j++) {
			особь.пары_меняющихся_узлов.add(Math.floor(последовательность_индексов_городов.next()) as Double)
		}
		особь.маршрут = преобразовать_в_маршрут(особь.пары_меняющихся_узлов)
		особь.длина_маршрута = подсчёт_длины_маршрута(особь.маршрут)
	}
}

type Массив_длин_маршрутов {
	ArrayList<Double> длины_маршрутов
}

resource массив_лучших = Массив_длин_маршрутов.create(new ArrayList<Double>())

event Эволюция(){
	сброс_флагов_особей()
	скрещивание()
	мутация()
	отбор()
	массив_лучших.длины_маршрутов.add(кратчайший_путь())
	Эволюция.plan(currentTime + 1)
}

def terminateCondition(){
	if (массив_лучших.длины_маршрутов.size() > количество_поколений_для_условия_остановки) {
		if (массив_лучших.длины_маршрутов.get(массив_лучших.длины_маршрутов.size() - 1) >=
			массив_лучших.длины_маршрутов.get(массив_лучших.длины_маршрутов.size() -
				количество_поколений_для_условия_остановки)) {
			return true
		}
	}
	return false
}

void мутация() {
	var количество_мутировавших_особей = 0
	for (мутирующая_особь : Особи.all.filter[флаг_скрещивания == false && флаг_мутации == false]) {
		if (количество_мутировавших_особей > количество_особей_на_мутацию)
			return;
		количество_мутировавших_особей = количество_мутировавших_особей + 1
		var Особи мутировавшая_особь = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			мутирующая_особь.длина_маршрута, 0, false, false, false)
		for (ген : мутирующая_особь.пары_меняющихся_узлов) {
			мутировавшая_особь.пары_меняющихся_узлов.add(ген)
		}
		for (var j = 0; j < количество_генов_на_мутацию; j++) {
			мутировавшая_особь.пары_меняющихся_узлов.set(Math.floor(последовательность_индексов_генов.next()) as int,
				Math.floor(последовательность_индексов_городов.next()) as Double)
		}
		мутирующая_особь.флаг_мутации = true
		мутировавшая_особь.флаг_мутации = true
		мутировавшая_особь.поколение = мутирующая_особь.поколение + 1
		мутировавшая_особь.маршрут = преобразовать_в_маршрут(мутировавшая_особь.пары_меняющихся_узлов)
		мутировавшая_особь.длина_маршрута = подсчёт_длины_маршрута(мутировавшая_особь.маршрут)
	}
}

void скрещивание() {
	for (var i = 0; i < Math.floor(количество_особей_на_скрещивание / 2) && Особи.all.filter [
		флаг_мутации == false && флаг_скрещивания == false
	].size() > 2; i++) {
		var Особи особь_предок_1 = Особи.all.filter [
			флаг_мутации == false && флаг_скрещивания == false
		].maxBySafe[длина_маршрута]
		особь_предок_1.флаг_скрещивания = true
		var Особи особь_предок_2 = Особи.all.filter [
			флаг_мутации == false && флаг_скрещивания == false
		].maxBySafe[длина_маршрута]
		особь_предок_2.флаг_скрещивания = true
		var особь_потомок_1 = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			особь_предок_1.длина_маршрута, особь_предок_1.поколение + 1, false, false, false)
		var Особи особь_потомок_2 = Особи.create(new ArrayList<Double>(), new ArrayList<Города>(),
			особь_предок_2.длина_маршрута, особь_предок_2.поколение + 1, false, false, false)

		for (ген : особь_предок_1.пары_меняющихся_узлов) {
			особь_потомок_1.пары_меняющихся_узлов.add(ген)
		}

		for (ген : особь_предок_2.пары_меняющихся_узлов) {
			особь_потомок_2.пары_меняющихся_узлов.add(ген)
		}

		var ArrayList<Double> temp = new ArrayList<Double>()

		for (ген : особь_предок_2.пары_меняющихся_узлов) {
			temp.add(ген)
		}

		for (var j = 0; j < количество_точек_скрещивания; j++) {
			var точка_скрещивания = Math.floor(последовательность_индексов_генов.next())
			for (var int k = точка_скрещивания as int; k < особь_потомок_1.пары_меняющихся_узлов.size(); k++) {
				temp.set(k, особь_потомок_1.пары_меняющихся_узлов.get(k))
				особь_потомок_1.пары_меняющихся_узлов.set(k, особь_потомок_2.пары_меняющихся_узлов.get(k))
				особь_потомок_2.пары_меняющихся_узлов.set(k, temp.get(k))
			}
		}

		особь_потомок_1.поколение = особь_предок_1.поколение + 1
		особь_потомок_1.флаг_скрещивания = true
		особь_потомок_1.маршрут = преобразовать_в_маршрут(особь_потомок_1.пары_меняющихся_узлов)
		особь_потомок_1.длина_маршрута = подсчёт_длины_маршрута(особь_потомок_1.маршрут)

		особь_потомок_2.поколение = особь_предок_2.поколение + 1
		особь_потомок_2.флаг_скрещивания = true
		особь_потомок_2.маршрут = преобразовать_в_маршрут(особь_потомок_2.пары_меняющихся_узлов)
		особь_потомок_2.длина_маршрута = подсчёт_длины_маршрута(особь_потомок_2.маршрут)
	}
}

void отбор() {
	for (; Особи.all.size() > размер_популяции && Особи.all.filter[флаг_отбора == false].size() > 2;) {
		var Особи особь_1 = Особи.all.filter[флаг_отбора == false].any
		особь_1.флаг_отбора = true
		var Особи особь_2 = Особи.all.filter[флаг_отбора == false].any
		особь_2.флаг_отбора = true
		if (особь_1.длина_маршрута > особь_2.длина_маршрута) {
			особь_1.erase()
		} else {
			особь_2.erase()
		}

		if (Особи.all.filter[флаг_отбора == false].size() < 2) {
			for (; Особи.all.size() > размер_популяции;) {
				var особь = Особи.all.maxBySafe[длина_маршрута]
				особь.erase()
			}
		}
	}
}

void сброс_флагов_особей(){
	for (особь : Особи.all.filter[флаг_мутации == true]) {
		особь.флаг_мутации = false
	}
	for (особь : Особи.all.filter[флаг_скрещивания == true]) {
		особь.флаг_скрещивания = false
	}
	for (особь : Особи.all.filter[флаг_отбора == true]) {
		особь.флаг_отбора = false
	}
}

ArrayList<Города> преобразовать_в_маршрут(ArrayList<Double> пары_меняющихся_узлов){
	var ArrayList<Города> маршрут = new ArrayList<Города>()

	for (избранный : Города.all.filter[флаг_выбора == false]) {
		маршрут.add(избранный)
		избранный.флаг_выбора = true
	}
	сброс_флага_выбора()
	for (var i = 0; i < пары_меняющихся_узлов.size() - 1; i = i + 2) {
		маршрут = поменять_местами_элементы_в_массиве(маршрут, toInteger(пары_меняющихся_узлов.get(i)),
			toInteger(пары_меняющихся_узлов.get(i + 1)))
	}
	return маршрут
}

ArrayList<Города> поменять_местами_элементы_в_массиве(ArrayList<Города> маршрут, int p1, int p2){
	var Города temp = маршрут.get(p1)
	маршрут.set(p1, маршрут.get(p2))
	маршрут.set(p2, temp)
	return маршрут
}

int toInteger(Double value){
	return value.doubleValue() as int
}

double расстояние_между_точками(double x1, double y1, double x2, double y2){
	val y_diff = Math.abs(y1 - y2)
	val x_diff = Math.abs(x1 - x2)
	return Math.sqrt(y_diff * y_diff + x_diff * x_diff)
}

double подсчёт_длины_маршрута(ArrayList<Города> маршрут) {
	if (маршрут.size() <= 1)
		return 0
	var Города исходный = маршрут.get(0)
	var Города текущий = исходный
	var double общая_длина_пути = 0

	for (var i = 1; i < маршрут.size(); i++) {
		var Города следующий = маршрут.get(i)
		общая_длина_пути = общая_длина_пути + расстояние_между_точками(текущий.x, текущий.y, следующий.x, следующий.y)
		текущий = следующий
	}
	общая_длина_пути = общая_длина_пути + расстояние_между_точками(текущий.x, текущий.y, исходный.x, исходный.y)
	return общая_длина_пути
}

Double кратчайший_путь(){
	return Особи.all.minBySafe[длина_маршрута].длина_маршрута
}

result пробег = Result.create([кратчайший_путь()])
