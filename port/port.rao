enum Состояние_буксира {Стоит_у_очереди, Идет_к_причалам, Стоит_у_причалов, Идет_к_очереди}
enum Номер_причала {_1, _2, _3} // костыыыль
enum Состояние_причала {Свободен, Занят}
enum Состояние_шторма {Спокоен, Штормит, Начался}
enum Тип_танкера {Тип1, Тип2, Тип3}
enum Состояние_танкера {Пришел, Буксируется_к_причалам, Ожидает_у_причалов, Заполняется, Заполнен, Буксируется_от_причалов, Ушел}

constant ширина = 600
constant высота = 350
constant граница_очереди = ширина / 3
constant граница_причалов = 5 * ширина / 6

type Порт {
	int количество_в_очереди;
	int номер_крайнего_танкера;
}

type Буксиры {
	Состояние_буксира состояние;
	int количество_обслуженных;
	int номер_танкера;
	/* Анимация */
	int размер;
	int X;
	int Y;
	RaoColor цвет;
}

type Танкеры {
	Тип_танкера тип;
	Состояние_танкера состояние;
	double время_прихода;
	int порядковый_номер;
}

type Причалы {
	Номер_причала номер;
	Состояние_причала состояние;
	int количество_обслуженных_причалом;
	Тип_танкера тип_танкера;
	Состояние_танкера состояние_танкера;
}

type Штормы {
	Состояние_шторма состояние;
	RaoColor цвет;
}


resource порт = Порт.create(0, 0)
//resource буксир = Буксиры.create(Состояние_буксира.Стоит_у_очереди, 0, 0, 30, ширина / 2, высота_границы_очереди, RaoColor.GREEN);
resource шторм = Штормы.create(Состояние_шторма.Спокоен, RaoColor.GRAY);


sequence интервал_прихода1 = new Values(#[10]);
sequence интервал_прихода2 = new Values(#[15]);
sequence интервал_прихода3 = new Values(#[20]);
sequence длительность_буксирования = new Values(#[5]);
sequence длительность_заполнения1 = new Values(#[31]);
sequence длительность_заполнения2 = new Values(#[32]);
sequence длительность_заполнения3 = new Values(#[33]);
sequence периодичность_шторма = new Values(#[90]);
sequence длительность_шторма = new Values(#[20]);

event Событие_прихода_танкера1() {
	Танкеры.create(Тип_танкера.Тип1, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера1.plan(currentTime + интервал_прихода1.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}

event Событие_прихода_танкера2() {
	Танкеры.create(Тип_танкера.Тип2, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера2.plan(currentTime + интервал_прихода2.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}

event Событие_прихода_танкера3() {
	Танкеры.create(Тип_танкера.Тип3, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера3.plan(currentTime + интервал_прихода3.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}


event Событие_начала_шторма() {
	шторм.состояние = Состояние_шторма.Начался;
	Событие_начала_шторма.plan(currentTime + периодичность_шторма.next());
}


operation Образец_шторма() {
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Начался];

	def duration() {
		return длительность_шторма.next();
	}
	def begin() {
		_шторм.состояние = Состояние_шторма.Штормит;
	}
	def end() {
		_шторм.состояние = Состояние_шторма.Спокоен;		
	}
}

operation Образец_буксирования_пустого_танкера() {
	relevant _порт = порт.onlyif[количество_в_очереди > 0];
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant буксир = Буксиры.accessible.filter[состояние == Состояние_буксира.Стоит_у_очереди].any;
	relevant танкер = Танкеры.accessible.filter[состояние == Состояние_танкера.Пришел].minBySafe[время_прихода];
	relevant причал = Причалы.accessible.filter[состояние == Состояние_причала.Свободен].any;

	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		порт.количество_в_очереди = порт.количество_в_очереди - 1;
		буксир.состояние = Состояние_буксира.Идет_к_причалам;
		буксир.номер_танкера = танкер.порядковый_номер;
		танкер.состояние = Состояние_танкера.Буксируется_к_причалам;
		
		/* Анимация */
		буксир._X = граница_очереди + 120; // на полкорпуса ниже границы очереди
	}
	def end() {
		буксир.состояние = Состояние_буксира.Стоит_у_причалов;
		танкер.состояние = Состояние_танкера.Ожидает_у_причалов;
		
		/* Анимация */
		буксир._X = граница_причалов - буксир.размер;
	}
}


operation Образец_заполнения_танкера() {
	//relevant _буксир = буксир.onlyif[состояние_буксира == Состояние_буксира.Стоит_у_причала]; 					// ?зачем?
	relevant танкер = Танкеры.accessible.filter[состояние == Состояние_танкера.Ожидает_у_причалов].any; 
	relevant причал = Причалы.accessible.filter[состояние == Состояние_причала.Свободен].any;	
	
	def duration(){
		switch танкер.тип {
		case Тип_танкера.Тип1:
			return длительность_заполнения1.next()
		case Тип_танкера.Тип2:
			return длительность_заполнения2.next()
		case Тип_танкера.Тип3:
			return длительность_заполнения3.next()
		}
	}

	def begin() {
		причал.состояние = Состояние_причала.Занят;
		танкер.состояние = Состояние_танкера.Заполняется;
		причал.тип_танкера = танкер.тип;
		причал.состояние_танкера = танкер.состояние;
	}
	def end() {
		причал.состояние = Состояние_причала.Свободен;
		причал.количество_обслуженных_причалом = причал.количество_обслуженных_причалом + 1;
		танкер.состояние = Состояние_танкера.Заполнен;
		причал.состояние_танкера = танкер.состояние;
	}
}


operation Образец_буксирования_заполненного_танкера() {
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant буксир = Буксиры.accessible.filter[состояние == Состояние_буксира.Стоит_у_причалов].any;
	relevant танкер = Танкеры.accessible.filter[состояние == Состояние_танкера.Заполнен].any;		

	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		буксир.состояние = Состояние_буксира.Идет_к_очереди;
		буксир.номер_танкера = танкер.порядковый_номер;
		танкер.состояние = Состояние_танкера.Буксируется_от_причалов;
		
		/* Анимация */
		буксир._X = граница_причалов - буксир.размер - 120; 
	}
	def end() {
		буксир.состояние = Состояние_буксира.Стоит_у_очереди;
		буксир.количество_обслуженных =  буксир.количество_обслуженных + 1;
		танкер.состояние == Состояние_танкера.Ушел;
		/*
		def execute(){
			_Танкер.erase();
		}
		*/
		/* Анимация */
		буксир._X = граница_очереди;
	}
}


operation Образец_перемещения_пустого_буксира_к_очереди() {
	relevant _порт = порт.onlyif[количество_в_очереди > 0];
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant буксир = Буксиры.accessible.filter[состояние == Состояние_буксира.Стоит_у_причалов].any;
	relevant танкер = Танкеры.accessible.filter[состояние == Состояние_танкера.Пришел].any;
	relevant причал = Причалы.accessible.filter[состояние == Состояние_причала.Свободен].any;	
	
	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		буксир.состояние = Состояние_буксира.Идет_к_очереди;
		буксир.номер_танкера = 0;
		
		/* Анимация */
		буксир._X = граница_причалов - буксир.размер - 120;
	}
	def end() {
		буксир.состояние = Состояние_буксира.Стоит_у_очереди;
		
		/* Анимация */
		буксир._X = граница_очереди;
	}
}


logic Работа_модели {
	activity буксирование_танкера_к_причалу = new Activity(Образец_буксирования_пустого_танкера.create());
	activity заполнение_танкера = new Activity(Образец_заполнения_танкера.create());
	activity буксирование_танкера_от_причала = new Activity(Образец_буксирования_заполненного_танкера.create());
	activity штормление = new Activity(Образец_шторма.create());
	activity возвращение_буксира_к_очереди = new Activity(Образец_перемещения_пустого_буксира_к_очереди.create());
}

def init() {
	Timer.plan(currentTime + 1);
	Причалы.create(Номер_причала._1, Состояние_причала.Свободен, 0, null, null);
	Причалы.create(Номер_причала._2, Состояние_причала.Свободен, 0, null, null);
	Причалы.create(Номер_причала._3, Состояние_причала.Свободен, 0, null, null);
	Буксиры.create(Состояние_буксира.Стоит_у_очереди, 0, 0, 70, граница_очереди, высота / 2, RaoColor.GREEN);
	Событие_прихода_танкера1.plan(currentTime + интервал_прихода1.next());
	Событие_прихода_танкера2.plan(currentTime + интервал_прихода2.next());
	Событие_прихода_танкера3.plan(currentTime + интервал_прихода3.next());
	Событие_начала_шторма.plan(currentTime + периодичность_шторма.next());   
	//log(" Танкеры: " + порт.танкеры_в_очереди)    
}

def terminateCondition() {
	return currentTime >= 240; //7 * 12 * 60;
}


result занятость_буксира = new Result([Буксиры.all.any.состояние]);
result длина_очереди = new Result([порт.количество_в_очереди]);
result Всего_обслужено_Митей = new Result([Буксиры.all.any.количество_обслуженных]);
result занятость_причала_1 = new Result([Причалы.all.filter[номер == Номер_причала._1].any.состояние]);
result занятость_причала_2 = new Result([Причалы.all.filter[номер == Номер_причала._2].any.состояние]);
result занятость_причала_3 = new Result([Причалы.all.filter[номер == Номер_причала._3].any.состояние]);
result Всего_заполнено_причалом_1 = new Result([Причалы.all.filter[номер == Номер_причала._1].any.количество_обслуженных_причалом]);
result Всего_заполнено_причалом_2 = new Result([Причалы.all.filter[номер == Номер_причала._2].any.количество_обслуженных_причалом]);
result Всего_заполнено_причалом_3 = new Result([Причалы.all.filter[номер == Номер_причала._3].any.количество_обслуженных_причалом]);
result Пропускная_способность = new Result([Буксиры.all.any.количество_обслуженных / currentTime * 60]);
result Длительность_работы = new Result([currentTime / 60]);

/* Animation */



event Timer() {
	//relevant _буксир = буксир;
	log(currentTime)
	for (Буксиры буксир : Буксиры.all){
		val шаг_хода_буксира = (((граница_причалов - 1.5 * буксир.размер) 
								- (граница_очереди + 1.5 * буксир.размер)) / 5) as int // исправить 5 на int(длительность_буксирования)
										
		if (буксир.состояние == Состояние_буксира.Идет_к_причалам){
			буксир._X = буксир._X + шаг_хода_буксира
			//log("Буксир едет к причалу. Y = " + буксир._Y + ". T: " + currentTime)
		}
		if (буксир.состояние == Состояние_буксира.Идет_к_очереди){
			буксир._X = буксир._X - шаг_хода_буксира
			//log("Буксир едет к очереди. Y = " + буксир._Y + ". T: " + currentTime)
		}
		log(currentTime + ". Буксир: X=" + буксир._X + " Y=" + буксир._Y)
	}
			
	Timer.plan(currentTime + 1);
}

RaoColor Цвет_по_типу (Тип_танкера тип){
	switch тип {
		case Тип_танкера.Тип1:
			return RaoColor.RED
		case Тип_танкера.Тип2:
			return RaoColor.BLUE
		case Тип_танкера.Тип3:
			return RaoColor.YELLOW
		default:
			return RaoColor.BLACK
	}
		
}
String Картинка_танкера (Тип_танкера тип_танкера, Состояние_танкера состояние){
	var тип = "";
	if (тип_танкера == Тип_танкера.Тип1)
		тип = "1"
	else if (тип_танкера == Тип_танкера.Тип2)
		тип = "2"
	else if (тип_танкера == Тип_танкера.Тип3)
		тип = "3"
	
	if (состояние == Состояние_танкера.Буксируется_к_причалам || состояние == Состояние_танкера.Пришел)
			return "images/tanker" + тип + "_empty.png"
	else if (состояние == Состояние_танкера.Буксируется_от_причалов)
			return "images/tanker" + тип + "_full.png"
}

frame Кадр_порта {
	def init() {
		background = new Background(ширина, высота, RaoColor.WHITE)
	}	
	
	def draw() {
		/* Фон */
		if (шторм.состояние != Состояние_шторма.Спокоен){
			drawImage("images/storm.png", 0, 0);
		}
		else{
			drawImage("images/calm.png", 0, 0);
		}
		
		/* Отрисовка статики */	
		drawLine(граница_очереди, 0, граница_очереди, ширина, RaoColor.BLACK); // Зона очереди
		drawLine(граница_причалов, 0, граница_причалов, ширина, RaoColor.BLACK); // Зона причалов
			
		/* Отрисовка */
		
		// буксирование
		for (Буксиры буксир : Буксиры.all){
			//буксир
			if (буксир.состояние == Состояние_буксира.Идет_к_очереди || буксир.состояние == Состояние_буксира.Стоит_у_причалов)
				drawImage("images/tugboat-to-queue.png", буксир._X, буксир._Y)
			else if (буксир.состояние == Состояние_буксира.Идет_к_причалам || буксир.состояние == Состояние_буксира.Стоит_у_очереди)
				drawImage("images/tugboat-to-berths.png", буксир._X, буксир._Y)
			//drawText(Integer.toString(буксир._количество_обслуженных), буксир._X + 3, буксир._Y + 3); // изменить число
			
			//танкер
			for (Танкеры плывущий_танкер : Танкеры.all.filter[порядковый_номер == буксир.номер_танкера]){
				if (плывущий_танкер.состояние == Состояние_танкера.Буксируется_к_причалам)
					drawImage(Картинка_танкера(плывущий_танкер.тип, плывущий_танкер.состояние), буксир._X - 120, буксир._Y)
				else if (плывущий_танкер.состояние == Состояние_танкера.Буксируется_от_причалов)
					drawImage(Картинка_танкера(плывущий_танкер.тип, плывущий_танкер.состояние), буксир._X + буксир.размер, буксир._Y)
			}
		}
				
		// очередь
		/* 
		var пустое_место = 0;
		for (Танкеры танкер_в_очереди : Танкеры.all){
			var место = танкер_в_очереди.порядковый_номер;
			if (танкер_в_очереди.состояние == Состояние_танкера.Пришел){
				drawImage(Картинка_танкера(танкер_в_очереди.тип, танкер_в_очереди.состояние, ""), 15 + (место % 4) * 40, высота_границы_очереди - 35 - (место / 4) * 120 + (пустое_место / 4) * 120)
				//drawRectangle(15 + (место % 4) * 40, высота_границы_очереди - 35 - (место / 4) * 40 + (пустое_место / 4) * 40, 30, 30, RaoColor.BLACK, RaoColor.BLACK)
			}
			else
			 	пустое_место = пустое_место + 1
		}
		*/
		
		// причалы
		for (Причалы причал : Причалы.all){
			var отступ = 0;
			switch причал.номер {
				case _1:
					отступ = 0
				case _2:
					отступ = 1
				case _3:
					отступ = 2
			}
			
			if (причал.состояние_танкера == Состояние_танкера.Заполняется || причал.состояние_танкера == Состояние_танкера.Заполнен){
				drawImage(Картинка_танкера(причал.тип_танкера, Состояние_танкера.Пришел), ширина - 120, 50 + отступ * 100)	
			}
			if (причал.состояние == Состояние_причала.Занят)
				drawRectangle(ширина - 50, 80 + отступ * 100, 50, 10, RaoColor.WHITE, RaoColor.BLACK)
			else
				drawRectangle(ширина - 50, 80 + отступ * 100, 50, 10, RaoColor.BLACK, RaoColor.BLACK)
		}
	}
}