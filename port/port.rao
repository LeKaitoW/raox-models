
enum Состояние_буксира {Стоит_у_очереди, Стоит_у_причала, Занят}
enum Направление_буксира {К_очереди, К_причалам}
enum Состояние_причала {Свободен, Занят}
enum Состояние_шторма {Спокоен, Штормит, Начался}
enum Тип_танкера {Тип1, Тип2, Тип3}
enum Состояние_танкера {Пришел, Ожидает_заполнения, Заполняется, Заполнен}

constant ширина = 350
constant высота = 600
constant высота_границы_очереди = высота / 3
constant высота_границы_причалов = 2 * высота / 3

type Порт {
	int количество_в_очереди;
	int номер_крайнего_танкера; 
}

type Буксиры {
	Состояние_буксира состояние_буксира;
	int количество_обслуженных;
	/* Анимация */
	int размер;
	int X;
	int Y;
	RaoColor цвет;
	Направление_буксира направление_буксира;
}

type Причалы {
	Состояние_причала состояние_причала;
	int количество_обслуженных_причалом;
}

type Танкеры {
	Тип_танкера тип;
	Состояние_танкера состояние;
	double время_прихода;
	int порядковый_номер;
}

type Штормы {
	Состояние_шторма состояние;
	RaoColor цвет
}


resource порт = Порт.create(0, 0)
resource буксир = Буксиры.create(Состояние_буксира.Стоит_у_очереди, 0, 30, ширина / 2, высота_границы_очереди, RaoColor.GREEN, Направление_буксира.К_причалам);
resource причал1 = Причалы.create(Состояние_причала.Свободен, 0);
resource причал2 = Причалы.create(Состояние_причала.Свободен, 0);
resource причал3 = Причалы.create(Состояние_причала.Свободен, 0);
resource шторм = Штормы.create(Состояние_шторма.Спокоен, RaoColor.GRAY);


sequence интервал_прихода1 = new Values(#[10]);
sequence интервал_прихода2 = new Values(#[15]);
sequence интервал_прихода3 = new Values(#[20]);
sequence длительность_буксирования = new Values(#[5]);
sequence длительность_заполнения1 = new Values(#[31]);
sequence длительность_заполнения2 = new Values(#[32]);
sequence длительность_заполнения3 = new Values(#[33]);
sequence периодичность_шторма = new Values(#[90]);
sequence длительность_шторма = new Values(#[20]);


event Событие_прихода_танкера1() {
	Танкеры.create(Тип_танкера.Тип1, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера1.plan(currentTime + интервал_прихода1.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}

event Событие_прихода_танкера2() {
	Танкеры.create(Тип_танкера.Тип2, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера2.plan(currentTime + интервал_прихода2.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}

event Событие_прихода_танкера3() {
	Танкеры.create(Тип_танкера.Тип3, Состояние_танкера.Пришел, currentTime, порт.номер_крайнего_танкера + 1);
	Событие_прихода_танкера3.plan(currentTime + интервал_прихода3.next());
	порт.количество_в_очереди = порт.количество_в_очереди + 1;
	порт.номер_крайнего_танкера = порт.номер_крайнего_танкера + 1;
}

event Событие_начала_шторма() {
	шторм.состояние = Состояние_шторма.Начался;
	Событие_начала_шторма.plan(currentTime + периодичность_шторма.next());
}


operation Образец_шторма() {
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Начался];

	def duration() {
		return длительность_шторма.next();
	}
	def begin() {
		_шторм.состояние = Состояние_шторма.Штормит;
	}
	def end() {
		_шторм.состояние = Состояние_шторма.Спокоен;		
	}
}

operation Образец_буксирования_пустого_танкера() {
	relevant _буксир = буксир.onlyif[
		состояние_буксира == Состояние_буксира.Стоит_у_очереди && порт.количество_в_очереди > 0
		];
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant _Танкер = Танкеры.all.filter[состояние == Состояние_танкера.Пришел].minBySafe[время_прихода];

	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		порт.количество_в_очереди = порт.количество_в_очереди - 1;
		_буксир.состояние_буксира = Состояние_буксира.Занят;
		_буксир.направление_буксира = Направление_буксира.К_причалам;
		
		/* Анимация */
		_буксир._Y = высота_границы_очереди + _буксир.размер / 2; // на полкорпуса ниже границы очереди
	}
	def end() {
		_буксир.состояние_буксира = Состояние_буксира.Стоит_у_причала;
		_Танкер.состояние = Состояние_танкера.Ожидает_заполнения;
		
		/* Анимация */
		_буксир._Y = высота_границы_причалов - 3 * _буксир.размер / 2;
	}
}


operation Образец_заполнения_танкера() {
	relevant _буксир = буксир.onlyif[состояние_буксира == Состояние_буксира.Стоит_у_причала];
	relevant _Танкер = Танкеры.accessible.filter[состояние == Состояние_танкера.Ожидает_заполнения].any; 
	relevant _Причал = Причалы.accessible.filter[состояние_причала == Состояние_причала.Свободен].any;	
	
	def duration(){
		switch _Танкер.тип {
		case Тип_танкера.Тип1:
			return длительность_заполнения1.next()
		case Тип_танкера.Тип2:
			return длительность_заполнения2.next()
		case Тип_танкера.Тип3:
			return длительность_заполнения3.next()
		}
	}

	def begin() {
		_Причал.состояние_причала = Состояние_причала.Занят;
		_Танкер.состояние = Состояние_танкера.Заполняется;
	}
	def end() {
		_Причал.состояние_причала = Состояние_причала.Свободен;
		_Причал.количество_обслуженных_причалом = _Причал.количество_обслуженных_причалом + 1;
		_Танкер.состояние = Состояние_танкера.Заполнен;
	}
}


operation Образец_буксирования_заполненного_танкера() {
	relevant _буксир = буксир.onlyif[состояние_буксира == Состояние_буксира.Стоит_у_причала];
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant _Танкер = Танкеры.all.filter[состояние == Состояние_танкера.Заполнен].any;		

	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		_буксир.состояние_буксира = Состояние_буксира.Занят;
		_буксир.направление_буксира = Направление_буксира.К_очереди;
		
		/* Анимация */
		_буксир._Y = высота_границы_причалов - 3 * _буксир.размер / 2; 
	}
	def end() {
		_буксир.состояние_буксира = Состояние_буксира.Стоит_у_очереди;
		_буксир.количество_обслуженных =  _буксир.количество_обслуженных + 1;
		
		/* Анимация */
		_буксир._Y = высота_границы_очереди + _буксир.размер / 2;
	}
}


operation Образец_перемещения_пустого_буксира_к_очереди() {
	relevant _буксир = буксир.onlyif[
		состояние_буксира == Состояние_буксира.Стоит_у_причала && порт.количество_в_очереди > 0
		];
	relevant _шторм = шторм.onlyif[состояние == Состояние_шторма.Спокоен];
	relevant _Танкер = Танкеры.all.filter[состояние == Состояние_танкера.Пришел].any;
	relevant _Причал = Причалы.all.filter[состояние_причала == Состояние_причала.Свободен].any;	
	
	def duration() {
		return длительность_буксирования.next();
	}
	def begin() {
		_буксир.состояние_буксира = Состояние_буксира.Занят;
		_буксир.направление_буксира = Направление_буксира.К_очереди;
		
		/* Анимация */
		_буксир._Y = высота_границы_причалов - 3 * _буксир.размер / 2;
	}
	def end() {
		_буксир.состояние_буксира = Состояние_буксира.Стоит_у_очереди;
		
		/* Анимация */
		_буксир._Y = высота_границы_очереди + _буксир.размер / 2;
	}
}


logic Работа_модели {
	activity буксирование_танкера_к_причалу = new Activity(Образец_буксирования_пустого_танкера.create());
	activity заполнение_танкера = new Activity(Образец_заполнения_танкера.create());
	activity буксирование_танкера_от_причала = new Activity(Образец_буксирования_заполненного_танкера.create());
	activity штормление = new Activity(Образец_шторма.create());
	activity возвращение_буксира_к_очереди = new Activity(Образец_перемещения_пустого_буксира_к_очереди.create());
}
boolean Триггер(Буксиры буксир){
	return false;
}

def init() {
	Timer.plan(currentTime + 1);
	Событие_прихода_танкера1.plan(currentTime + интервал_прихода1.next());
	Событие_прихода_танкера2.plan(currentTime + интервал_прихода2.next());
	Событие_прихода_танкера3.plan(currentTime + интервал_прихода3.next());
	Событие_начала_шторма.plan(currentTime + периодичность_шторма.next());       
}

def terminateCondition() {
	return currentTime >= 240; //7 * 12 * 60;
}


result занятость_буксира = new Result([буксир.состояние_буксира]);
result длина_очереди = new Result([порт.количество_в_очереди]);
result Всего_обслужено_Митей = new Result([буксир.количество_обслуженных]);
result занятость_причала1 = new Result([причал1.состояние_причала]);
result Всего_заполнено_причалом1 = new Result([причал1.количество_обслуженных_причалом]);
result Всего_заполнено_причалом2 = new Result([причал2.количество_обслуженных_причалом]);
result Всего_заполнебуксирлом3 = new Result([причал3.количество_обслуженных_причалом]);
result Пропускная_способность = new Result([буксир.количество_обслуженных / currentTime * 60]);
result Длительность_работы = new Result([currentTime / 60]);

/* Animation */



event Timer() {
	//relevant _буксир = буксир;
	
	if (буксир.состояние_буксира == Состояние_буксира.Занят) {
		val шаг_хода_буксира = (((высота_границы_причалов - 1.5 * буксир.размер) 
								- (высота_границы_очереди + 1.5 * буксир.размер)) / 5) as int // исправить 5 на int(длительность_буксирования)
		if (буксир.направление_буксира == Направление_буксира.К_причалам){
			буксир._Y = буксир._Y + шаг_хода_буксира
			//log("Буксир едет к причалу. Y = " + буксир._Y + ". T: " + currentTime)
		}
		if (буксир.направление_буксира == Направление_буксира.К_очереди){
			буксир._Y = буксир._Y - шаг_хода_буксира
			//log("Буксир едет к очереди. Y = " + буксир._Y + ". T: " + currentTime)
		}
	}
	
	/*
	if (порт.количество_в_очереди > 0){
		val 
	}
	*/
	

	Timer.plan(currentTime + 1);
}



frame Кадр_порта {
	def init() {
		background = new Background(ширина, высота, RaoColor.WHITE)
	}	
	
	def draw() {
		/* Фон */
		if (шторм.состояние != Состояние_шторма.Спокоен){
			drawImage("images/storm.jpg", 0, 0);
		}
		var i = 0;
		for (Танкеры танк : Танкеры.all.filter[состояние == Состояние_танкера.Пришел]){
			switch танк.тип {
				case Тип1: 
					drawRectangle(15 + (i % 8) * 40, высота_границы_очереди - 35 - (i / 8) * 40, 30, 30, RaoColor.RED, RaoColor.BLACK)
				case Тип2:
					drawRectangle(15 + (i % 8)* 40, высота_границы_очереди - 35 - (i / 8) * 40, 30, 30, RaoColor.BLUE, RaoColor.BLACK)
				case Тип3:
					drawRectangle(15 + (i % 8)* 40, высота_границы_очереди - 35 - (i / 8) * 40, 30, 30, RaoColor.YELLOW, RaoColor.BLACK)
			}
			i = i + 1;
		}
		
		
		/* Отрисовка статики */	
		drawLine(0, высота_границы_очереди, ширина, высота_границы_очереди, RaoColor.BLACK); // Зона очереди
		drawLine(0, высота_границы_причалов, ширина, высота_границы_причалов, RaoColor.BLACK); // Зона причалов
			
		/* Отрисовка */
		drawRectangle(буксир._X, буксир._Y, буксир.размер, буксир.размер, буксир.цвет, буксир.цвет); //
		drawText(Integer.toString(буксир._количество_обслуженных), буксир._X + 3, буксир._Y + 3);
		
	}
}
