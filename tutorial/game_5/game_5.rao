enum Место_дырки {СПРАВА, СЛЕВА, СВЕРХУ, СНИЗУ, ДЫРКИ_РЯДОМ_НЕТ}

type Фишки {
	int номер;
	int место;
}

type Дырка {
	int место;
}

resource фишка1 = Фишки.create(1, 2);
resource фишка2 = Фишки.create(2, 3);
resource фишка3 = Фишки.create(3, 6);
resource фишка4 = Фишки.create(4, 4);
resource фишка5 = Фишки.create(5, 5);
resource дырка = Дырка.create(1);

rule Перемещение_фишки (Место_дырки куда_перемещать, int на_сколько_перемещать) {
	relevant _фишка = Фишки.accessible.filter[где_дырка(место) == куда_перемещать].any();
	relevant _дырка = дырка;

	def execute() {
		_фишка.место = _фишка.место + на_сколько_перемещать;
		_дырка.место = _дырка.место - на_сколько_перемещать;
	}
}

constant длина_поля = 3;

int ряд(int место) {
	return (место - 1 ) / длина_поля + 1
}

int столбец(int место) {
	return (место - 1) % длина_поля + 1
}

Место_дырки где_дырка(int место) {
	if (столбец(место) == столбец(дырка.место) && ряд(место) == ряд(дырка.место) + 1)
		return Место_дырки.СВЕРХУ

	if (столбец(место) == столбец(дырка.место) && ряд(место) == ряд(дырка.место) - 1)
		return Место_дырки.СНИЗУ

	if (ряд(место) == ряд(дырка.место) && столбец(место) == столбец(дырка.место) - 1)
		return Место_дырки.СПРАВА

	if (ряд(место) == ряд(дырка.место) && столбец(место) == столбец(дырка.место) + 1)
		return Место_дырки.СЛЕВА

	return Место_дырки.ДЫРКИ_РЯДОМ_НЕТ
}

search Расстановка_фишек {
	edge перемещение_вправо = new Edge(Перемещение_фишки.create(Место_дырки.СПРАВА, 1), 1)
	edge перемещение_влево = new Edge(Перемещение_фишки.create(Место_дырки.СЛЕВА, -1), 1)
	edge перемещение_вверх = new Edge(Перемещение_фишки.create(Место_дырки.СВЕРХУ, -длина_поля), 1)
	edge перемещение_вниз = new Edge(Перемещение_фишки.create(Место_дырки.СНИЗУ, длина_поля), 1)

	def init() {
		startCondition = [Фишки.accessible.exists[номер != место]]
		terminateCondition = [Фишки.accessible.forall[номер == место]]
		heuristic = [0.0]
		compareTops = true
	}
}
