import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider
import java.util.ArrayList

/* Connection data */

constant driver = "com.mysql.jdbc.Driver"

constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "observer"
constant password = "compaq"

//constant url = "jdbc:mysql://mikhailmineev.ru:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
//constant username = "jpademo"
//constant password = "5xYB2e6T5Jo7ajA"

dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest)
cursor orders = new ArrayList<Part>().iterator()

/* Model data */

constant terminateTime = 6000 // Время остановки минуты?
constant allowedDeliveryWaitPeriod = 4 // Допустимое время ожидания заказа, дни
constant defaultDeliveryTime = 3 // Время ожидания в днях
sequence orderRequestReceivedInterval = new Exponential(123456789, 1 / 30.0)

enum State {REQUESTERD, IN_TRANSIT, ARRIVED}

type PartRequestType {
	PartRequest partRequest
	State state
}

event OrderReceived() {
	val order = orders.next()
	for (partRequest : order.requestedParts) {
		PartRequestType.create(partRequest, State.REQUESTERD)
	}

	OrderReceived.plan(currentTime + orderRequestReceivedInterval.next())
}

operation PartProcessing() {
	relevant partRequest_ = PartRequestType.accessible.filter[state == State.REQUESTERD].any

	def begin() {
		partRequest_.state = State.IN_TRANSIT
	}

	def duration() {
		return defaultDeliveryTime
	}

	def end() {
		partRequest_.state = State.ARRIVED
	}
}

logic Model {
	activity partProcessing = new Activity(PartProcessing.create())
	activity utilizeProcessed = new Activity(UtilizeProcessed.create())
}

rule UtilizeProcessed() {
	relevant partRequest_ = PartRequestType.accessible.filter[state == State.ARRIVED].any

	def execute() {
		partRequest_.erase()
	}
}

def init() {
	val query = data.getQuery()
	val order = QOrder.order
	orders = query.from(order).fetch().iterator()
	OrderReceived.plan(orderRequestReceivedInterval.next())
}

def terminateCondition() {
	return currentTime >= terminateTime || !orders.hasNext()
}
