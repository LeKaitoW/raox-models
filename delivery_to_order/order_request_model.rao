import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider

import java.util.ArrayList
import java.util.List
import java.util.Map
import java.util.HashMap
import java.time.temporal.ChronoUnit
import java.time.LocalDate
import domain.LocalDateAttributeConverter

/* Connection data */
constant driver = "com.mysql.jdbc.Driver"

constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "Observer"
constant password = "CY73-YVRE-3FT2"

//constant url = "jdbc:mysql://mikhailmineev.ru:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
//constant username = "jpademo"
//constant password = "5xYB2e6T5Jo7ajA"

dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest, LocalDateAttributeConverter)

type OrderStats {
	Map<String, Part> localPartData
	long fails
	long successes
	List<Double> processDuration 
	List<Double> failPrices // В копейках, полагаю, если так в базе
	List<Double> successfulPrices
}

resource orderStats = OrderStats.create(new HashMap, 0, 0, new ArrayList, new ArrayList, new ArrayList)

long getModificationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfProcessing
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getModificationInterval " + interval)
	return interval
}

long getRealizationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfRealization
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getRealizationInterval " + interval)
	return interval
}

long getDeliveryInterval(PartRequest partRequest) {
	val start = partRequest.order.dateOfCreation
	val end = partRequest.dateOfDelivery
	val interval = start.until(end, ChronoUnit.DAYS)
	return interval
}

Part tryFetchLocal(Part part){
	if (!orderStats.localPartData.containsKey(part.id))
		orderStats.localPartData.put(part.id, part)
	return orderStats.localPartData.get(part.id)
}

Double calculatePrice(Order order){
	var sum = 0.0
	for (partRequest : order.requestedParts){
		val part = partRequest.part
		sum += part.purchaseprice * priceMultiplier
	}
	return sum
}

boolean takeParts(PartRequest request) {
	val part = tryFetchLocal(request.part)
	if (part.stocked >= request.count) {
		part.stocked -= request.count
		return true
	} else {
		part.stocked = 0
		return false
	}
}

/* Model data */
constant allowedDeliveryWaitPeriodDays = 3
constant priceMultiplier = 1.2
enum PartState {REQUESTED, IN_TRANSIT, ARRIVED}
enum OrderResult {OK, FAIL, LATE, EMPTY}
enum OrderState {REQUESTED, PROCESSING, FINISHED}

type OrderType {
	Order original
	OrderState state
	OrderResult resulted
	double creationTime
	double emptyProcessDuration
	List<PartRequestType> requests // One to many
}

type PartRequestType {
	PartRequest original
	PartState state
	double creationTime
	OrderType order // Many to one 
}

int waitPeriod() {
	return delivery_to_order.order_request_model.allowedDeliveryWaitPeriodDays
}

/* Order logic */
event OrderReceived(Order order) {
	if (order.requestedParts.isEmpty && order.dateOfRealization === null && order.dateOfProcessing === null) {
		return
	}
	OrderType.create(order, OrderState.REQUESTED, OrderResult.OK, currentTime, 0, new ArrayList())
	log("Created order " + order.id + "(time:" + currentTime + ")")
}

rule OrderProcessing() {
	relevant order = OrderType.accessible.filter[state == OrderState.REQUESTED].any

	def execute() {
		val parts = order.original.requestedParts
		if (parts.isEmpty) { // Пустые - заказы, по которым не смогли подобрать деталь, считаются неуспешными
			order.state = OrderState.FINISHED
			order.resulted = OrderResult.EMPTY
			log("Processed order (no parts) " + order.getNumber)
			return
		}
		for (partRequest : parts) {
			val partRequestType = PartRequestType.create(partRequest, PartState.REQUESTED, currentTime, order)
			order.requests.add(partRequestType)
		}
		order.state = OrderState.PROCESSING
		log("Processed order (created " + parts.size() + " parts) " + order.getNumber)
	}
}

rule UtilizeOrder() {
	relevant order = OrderType.accessible.filter[state == OrderState.FINISHED].any

	def execute() {
		order.erase()
		if (currentTime - order.creationTime > waitPeriod)
			order.resulted = OrderResult.LATE
		var duration = currentTime - order.creationTime
		switch (order.resulted) {
			case LATE: {
				orderStats.fails = orderStats.fails + 1
			}
			case FAIL: {
				orderStats.fails = orderStats.fails + 1
			}
			case OK: {
				orderStats.successes = orderStats.successes + 1
			}
			case EMPTY: {
				orderStats.fails = orderStats.fails + 1
				if (order.original.dateOfRealization !== null) {
					duration = getRealizationInterval(order.original)
				}
				duration = getModificationInterval(order.original)
			}
		}
		
		orderStats.processDuration.add(duration)
		if(order.resulted == OrderResult.OK)
			orderStats.successfulPrices.add(calculatePrice(order.original))
		else
			orderStats.failPrices.add(calculatePrice(order.original))
						
		log("Utilized order " + order.original.id + "\tResult:" + order.resulted + "\tDuration:" + duration + "\t")
	}
}

/* Part request logic */
operation PartProcessing() {
	relevant partRequest = PartRequestType.accessible.filter[state == PartState.REQUESTED].any

	def begin() {
		partRequest.state = PartState.IN_TRANSIT
	}

	def duration() {
		val order = partRequest.original.order
		val part = partRequest.original.part
		if (takeParts(partRequest.original)) {
			log("Деталь " + part.name + " взята со склада");
			return 0
		// Детали с датой доставки null считаем неотгруженными, для таких случаем возвращаем разницк создания и последнего изменения заказа
		} else if (partRequest.original.dateOfDelivery !== null && getDeliveryInterval(partRequest.original) > 0) {
			log("Деталь " + part.name + " будет доставлена через " + getDeliveryInterval(partRequest.original) +
				" дней");
			return getDeliveryInterval(partRequest.original)
		// Детали с отрицательной длительностью считаем уже на складе
		} else if (partRequest.original.dateOfDelivery !== null) {
			log("Деталь " + part.name + " имеет <0 длительность, считаем, что на складе");
			return 0
		} else if (order.dateOfRealization !== null) {
			log("Деталь " + part.name + " будет доставлена через " + getRealizationInterval(order) +
				" дней (по дате реализации заказа)");
			return getRealizationInterval(order)
		}
		log("Деталь " + part.name + " будет доставлена через " + getModificationInterval(order) +
			" дней (по дате изменения заказа)");
		return getModificationInterval(order)
	}

	def end() {
		partRequest.state = PartState.ARRIVED
	}
}

rule UtilizePartRequest() {
	relevant partRequest = PartRequestType.accessible.filter[state == PartState.ARRIVED].any

	def execute() {
		val orderType = partRequest.order
		orderType.requests.remove(partRequest)
		partRequest.erase()
		if (orderType.requests.isEmpty())
			orderType.state = OrderState.FINISHED
	}
}

logic Model {
	activity orderProcessing = new Activity(OrderProcessing.create())
	activity utilizeOrder = new Activity(UtilizeOrder.create())
	activity partProcessing = new Activity(PartProcessing.create())
	activity utilizePartRequest = new Activity(UtilizePartRequest.create())
}

def init() {
	val startDate = LocalDate.now.minusYears(1)
	val query = data.<Order>getQuery
	val qOrder = QOrder.order
	val orderList = query.from(qOrder).where(qOrder.dateOfCreation.after(startDate)).fetch
	//val orderList = query.from(qOrder).fetch

	for (order : orderList) {
		OrderReceived.plan(order.getEpochDayOfCreation(), order)
	}
	log("Orders total " + orderList.size)
}

def finish() {
	val percentage = orderStats.successes * 100 / (orderStats.successes + orderStats.fails)
	log("Result:\tOrders " + orderStats.successes + ":" + orderStats.fails + " Successful percentage: " + percentage + "%")
	val durationResults = orderStats.processDuration.stream.mapToDouble([f | f]).summaryStatistics
	val avg = durationResults.getAverage
	val max = durationResults.getMax
	val min = durationResults.getMin
	log("Duration:\tAverage " + avg + "\tMax:" + max + "\tMin:" + min)
	val failPriceResults = orderStats.failPrices.stream.mapToDouble([f | f]).summaryStatistics
	val avgFailPrice = failPriceResults.getAverage
	val successPriceResults = orderStats.successfulPrices.stream.mapToDouble([f | f]).summaryStatistics
	val avgSuccessPrice = successPriceResults.getAverage
	log("Average cost:\tsuccessful:" + avgSuccessPrice + "\tfail:" + avgFailPrice)
}

result fails = Result.create([orderStats.fails])
result successes = Result.create([orderStats.successes])
