import domain.LocalDateAttributeConverter
import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder
import domain.QPartRequest

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider

import java.util.ArrayList
import java.util.List
import java.time.temporal.ChronoUnit
import java.time.LocalDate

/* Connection data */
constant driver = "com.mysql.jdbc.Driver"

constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "Observer"
constant password = "CY73-YVRE-3FT2"

dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest, LocalDateAttributeConverter)

type OrderStats {
	long allowedWaitPeriodMultiplePartDays
	long fails
	long successes
	List<Double> failDuration
	List<Double> successfulDuration
	List<Double> failPrices
	List<Double> successfulPrices
}

resource orderStats = OrderStats.create(3, 0, 0, new ArrayList, new ArrayList, new ArrayList, new ArrayList)

long getModificationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfProcessing
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getModificationInterval " + interval)
	return interval
}

long getRealizationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfRealization
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getRealizationInterval " + interval)
	return interval
}

long getDeliveryInterval(PartRequest partRequest) {
	val start = partRequest.order.dateOfCreation
	val end = partRequest.dateOfDelivery
	val interval = start.until(end, ChronoUnit.DAYS)
	return interval
}

Double calculatePrice(OrderType orderType){
	val order = orderType.original
	var sum = orderType.deliveryPrices
	for (partRequest : order.requestedParts){
		val part = partRequest.part
		// TODO На обсуждении есть заказы с 0 ценами и отрацательной разницей + странно (закуп - продаж)
		/*if(part.purchaseprice <= 0 || part.sellingprice <= 0 || part.sellingprice - part.purchaseprice < 0) 
			blog(LogLevel.WARN, String.format("Part %s has strange prices purchase:%d celling:%d", part,
				part.purchaseprice, part.sellingprice))*/
		sum += part.sellingprice - part.purchaseprice
	}
	return sum
}

boolean takeParts(PartRequestType requestType) {
	val request = requestType.original
	val part = request.part
	// со склада
	if (part.stocked >= request.count) {
		part.stocked -= request.count
		return true
	// нужно заказать
	} else {
		// проверка будущей потребности, берем +1 месяц
		val startDate = requestType.original.order.dateOfCreation
		val endDate = startDate.plusMonths(1)
		val query = data.<PartRequest>getQuery
		val qpartRequest = QPartRequest.partRequest
		val partList = query.from(qpartRequest).where(
			qpartRequest.order.dateOfCreation.between(startDate, endDate).and(qpartRequest.eq(request))).fetch
			
		var futureRequirementCount = 0
		for(row : partList)
			futureRequirementCount += row.count
			
		var supplyAmount = 0
		if (futureRequirementCount == 1) {
			// вызываем курьера, за 700 рублей
			// сбрасываем число, не мог здесь оказаться, если деталей хватало, или если требовалось > 1
			supplyAmount = 1
			requestType.order.deliveryPrices = requestType.order.deliveryPrices + 700
		} else {
			// > 1, дозаказываем детали на 6 недель
			val endDateForDelivery = startDate.plusWeeks(6)
			val query2 = data.<PartRequest>getQuery
			val partListToAdd = query2.from(qpartRequest).where(
				qpartRequest.order.dateOfCreation.between(startDate, endDateForDelivery).and(
					qpartRequest.part.eq(part))).fetch

			for (row : partListToAdd)
				supplyAmount += row.count
				
			requestType.order.deliveryPrices = requestType.order.deliveryPrices + 1500
		}
		part.stocked += supplyAmount - request.count
		return false
	}
}

/* Model data */
constant allowedWaitPeriodSinglePartDays = 3
constant priceMultiplier = 1.2
enum PartState {REQUESTED, IN_TRANSIT, ARRIVED}
enum OrderResult {OK, FAIL, LATE, EMPTY}
enum OrderState {REQUESTED, PROCESSING, FINISHED}

type OrderType {
	Order original
	OrderState state
	OrderResult resulted
	double creationTime
	double emptyProcessDuration
	double deliveryPrices
	List<PartRequestType> requests
}

type PartRequestType {
	PartRequest original
	PartState state
	double creationTime
	OrderType order
}

long waitPeriod(OrderType order) {
	if(order.original.requestedParts.size == 1) {
		return 3
	} else {
		return orderStats.allowedWaitPeriodMultiplePartDays
	}
}

/* Order logic */
event OrderReceived(Order order) {
	if (order.requestedParts.isEmpty && order.dateOfRealization === null && order.dateOfProcessing === null) {
		return
	}
	OrderType.create(order, OrderState.REQUESTED, OrderResult.OK, currentTime, 0, 0, new ArrayList())
	// log("Created order " + order.id + "(time:" + currentTime + " creation:" + order.dateOfCreation + ")")
}

rule OrderProcessing() {
	relevant order = OrderType.accessible.filter[state == OrderState.REQUESTED].any

	def execute() {
		val parts = order.original.requestedParts
		if (parts.isEmpty) { // Пустые - заказы, по которым не смогли подобрать деталь, считаются неуспешными
			order.state = OrderState.FINISHED
			order.resulted = OrderResult.EMPTY
			//log(String.format("Processed order (no parts) %s", order.getNumber))
			return
		}
		for (partRequest : parts) {
			val partRequestType = PartRequestType.create(partRequest, PartState.REQUESTED, currentTime, order)
			order.requests.add(partRequestType)
		}
		order.state = OrderState.PROCESSING
		//log("Processed order (created " + parts.size() + " parts) " + order.getNumber)
	}
}

/* Part request logic */
operation PartProcessing() {
	relevant partRequest = PartRequestType.accessible.filter[state == PartState.REQUESTED].any

	def begin() {
		partRequest.state = PartState.IN_TRANSIT
	}

	def duration() {
		val order = partRequest.original.order
		val part = partRequest.original.part
		if (takeParts(partRequest)) {
			//log(String.format("Деталь %s взята со склада", part.name));
			return 0
		// Детали с датой доставки null считаем неотгруженными, для таких случаем возвращаем разницк создания и последнего изменения заказа
		} else if (partRequest.original.dateOfDelivery !== null && getDeliveryInterval(partRequest.original) >= 0) {
			//log("Деталь " + part.name + " будет доставлена через " + getDeliveryInterval(partRequest.original) +
			//	" дней");
			return getDeliveryInterval(partRequest.original)
		// Детали с отрицательной длительностью считаем уже на складе
		} else if (partRequest.original.dateOfDelivery !== null) {
			//log("Деталь " + part.name + " имеет <0 длительность, считаем, что на складе "+getDeliveryInterval(partRequest.original));
			return 0
		} else if (order.dateOfRealization !== null) {
			//log("Деталь " + part.name + " будет доставлена через " + getRealizationInterval(order) +
			// 	" дней (по дате реализации заказа)");
			return getRealizationInterval(order)
		}
		//log("Деталь " + part.name + " будет доставлена через " + getModificationInterval(order) +
		//	" дней (по дате изменения заказа)");
		return getModificationInterval(order)
	}

	def end() {
		partRequest.state = PartState.ARRIVED
	}
}

rule UtilizePartRequest() {
	relevant partRequest = PartRequestType.accessible.filter[state == PartState.ARRIVED].any

	def execute() {
		val orderType = partRequest.order
		orderType.requests.remove(partRequest)
		partRequest.erase()
		if (orderType.requests.isEmpty())
			orderType.state = OrderState.FINISHED
	}
}

rule UtilizeOrder() {
	relevant order = OrderType.accessible.filter[state == OrderState.FINISHED].any

	def execute() {
		order.erase()
		if (currentTime - order.creationTime > waitPeriod(order))
			order.resulted = OrderResult.LATE
		switch (order.resulted) {
			case LATE: {
				orderStats.fails = orderStats.fails + 1
				val duration = currentTime - order.creationTime
				orderStats.failDuration.add(duration)
			}
			case FAIL: {
				orderStats.fails = orderStats.fails + 1
				val duration = currentTime - order.creationTime
				orderStats.failDuration.add(duration)
			}
			case OK: {
				orderStats.successes = orderStats.successes + 1
				val duration = currentTime - order.creationTime
				orderStats.successfulDuration.add(duration)
			}
			case EMPTY: {
				orderStats.fails = orderStats.fails + 1
				var duration = 0.0
				if (order.original.dateOfRealization !== null) {
					duration = getRealizationInterval(order.original)
				}
				duration = getModificationInterval(order.original)
				orderStats.failDuration.add(duration)
			}
		}
		
		if(order.resulted == OrderResult.OK)
			orderStats.successfulPrices.add(calculatePrice(order))
		else
			orderStats.failPrices.add(calculatePrice(order))
						
		//log("Utilized order " + order.original.id + "\tResult:" + order.resulted + "\tDuration:" + duration + "\t")
	}
}

logic Model {
	activity orderProcessing = new Activity(OrderProcessing.create())
	activity utilizeOrder = new Activity(UtilizeOrder.create())
	activity partProcessing = new Activity(PartProcessing.create())
	activity utilizePartRequest = new Activity(UtilizePartRequest.create())
}

def experiments(){
	init
	for (var i = 0; i < 1; i++) {
		orderStats.fails = 0
		orderStats.successes = 0
		orderStats.failDuration.clear
		orderStats.successfulDuration.clear
		orderStats.failPrices.clear
		orderStats.successfulPrices.clear
		data.clear

		val startDate = LocalDate.now.minusYears(2)
		val query = data.<Order>getQuery
		val qOrder = QOrder.order
		val orderList = query.from(qOrder).where(qOrder.dateOfCreation.after(startDate)).orderBy(qOrder.id.asc).fetch
		for (order : orderList) {
			OrderReceived.plan(order.getEpochDayOfCreation(), order)
		}
		start
	}
}

def init() {
}

def finish() {
	val percentage = orderStats.successes * 100 / (orderStats.successes + orderStats.fails)
	log(
		String.format("Result: \t\tOrders: %d/%d Successful percentage: %d%%", orderStats.successes, orderStats.fails,
			percentage))
	val failResults = orderStats.failDuration.stream.mapToDouble([f | f]).summaryStatistics
	log(
		String.format("Fail duration: \tAverage: %f\tMax: %f\tMin: %f", failResults.getAverage, failResults.getMax,
			failResults.getMin))
	val successfulResults = orderStats.successfulDuration.stream.mapToDouble([f | f]).summaryStatistics
	log(
		String.format("Ok duration: \tAverage: %f\tMax: %f\tMin: %f", successfulResults.getAverage,
			successfulResults.getMax, successfulResults.
				getMin))
	val failPriceResults = orderStats.failPrices.stream.mapToDouble([f | f]).summaryStatistics
	log(String.format("Fail price: \tAverage: %f", failPriceResults.getAverage))
	val successPriceResults = orderStats.successfulPrices.stream.mapToDouble([f | f]).summaryStatistics
	log(String.format("Ok prive: \t\tAverage: %f", successPriceResults.getAverage))
	
	orderStats.allowedWaitPeriodMultiplePartDays = ((failResults.getAverage + successfulResults.getAverage) / 2).longValue
	log(String.format("New average wait: %d", orderStats.allowedWaitPeriodMultiplePartDays))
}

result fails = Result.create([orderStats.fails])
result successes = Result.create([orderStats.successes])
