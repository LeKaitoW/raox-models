import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider

import java.util.ArrayList
import java.util.List
import java.util.Map
import java.util.HashMap

/* Connection data */
constant driver = "com.mysql.jdbc.Driver"

constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "observer"
constant password = "compaq"

//constant url = "jdbc:mysql://mikhailmineev.ru:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
//constant username = "jpademo"
//constant password = "5xYB2e6T5Jo7ajA"
dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest)

type OrderStats {
	Map<String, Part> localPartData
	long fails
	long successes
}

resource orderStats = OrderStats.create(new HashMap, 0, 0)

Part tryFecthLocal(Part part){
	if (!orderStats.localPartData.containsKey(part.id))
		orderStats.localPartData.put(part.id, part)
	return orderStats.localPartData.get(part.id)
}

boolean takeParts(PartRequest request) {
	val part = tryFecthLocal(request.part)
	if (part.stocked >= request.count) {
		part.stocked -= request.count;
		return true;
	} else {
		part.stocked = 0;
		return false;
	}
}

/* Model data */
constant allowedDeliveryWaitPeriod = 3 // Допустимое время ожидания заказа, дни
enum PartState {REQUESTED, IN_TRANSIT, ARRIVED}
enum OrderResult {OK, FAIL, LATE, EMPTY}
enum OrderState {REQUESTED, PROCESSING, FINISHED}

type OrderType {
	Order original
	OrderState state
	OrderResult resulted
	double creationTime
	double emptyProcessDuration
	List<PartRequestType> requests // One to many
}

type PartRequestType {
	PartRequest original
	PartState state
	double creationTime
	OrderType order // Many to one 
}

int waitPeriod() {
	return allowedDeliveryWaitPeriod
}

/* Order logic */
event OrderReceived(Order order) {
	if (order.requestedParts.isEmpty && !order.hasRealizationInterval && !order.hasProcessingInterval) {
		return
	}
	val orderType = OrderType.create(order, OrderState.REQUESTED, OrderResult.OK, currentTime, 0, new ArrayList())
	log("Created order " + orderType.getNumber + "(time:" + currentTime + ")")
}

rule OrderProcessing() {
	relevant order = OrderType.accessible.filter[state == OrderState.REQUESTED].any

	def execute() {
		val parts = order.original.requestedParts
		if (parts.isEmpty) { // Пустые - заказы, по которым не смогли подобрать деталь, считаются неуспешными
			order.state = OrderState.FINISHED
			order.resulted = OrderResult.EMPTY
			log("Processed order (no parts) " + order.getNumber)
			return
		}
		for (partRequest : parts) {
			val partRequestType = PartRequestType.create(partRequest, PartState.REQUESTED, currentTime, order)
			order.requests.add(partRequestType)
		}
		order.state = OrderState.PROCESSING
		log("Processed order (created " + parts.size() + " parts) " + order.getNumber)
	}
}

rule UtilizeOrder() {
	relevant order = OrderType.accessible.filter[state == OrderState.FINISHED].any

	def execute() {
		order.erase()
		if (currentTime - order.creationTime > waitPeriod)
			order.resulted = OrderResult.LATE
		var duration = currentTime - order.creationTime
		switch (order.resulted) {
			case LATE: {
				orderStats.fails = orderStats.fails + 1
			}
			case FAIL: {
				orderStats.fails = orderStats.fails + 1
			}
			case OK: {
				orderStats.successes = orderStats.successes + 1
			}
			case EMPTY: {
				orderStats.fails = orderStats.fails + 1
				if (order.original.hasRealizationInterval) {
					duration = order.original.getRealizationInterval
				}
				duration = order.original.getModificationInterval
			}
		}
		val percentage = orderStats.successes * 100 / (orderStats.successes + orderStats.fails)
		log(
			"Utilized order " + order.getNumber + "\tResult:" + order.resulted + "\tDuration:" + duration +
				"\tOrders " + orderStats.successes + ":" + orderStats.fails + " Success percentage: " + percentage +
				"%")
			}
		}

		/* Part request logic */
		operation PartProcessing() {
			relevant partRequest = PartRequestType.accessible.filter[state == PartState.REQUESTED].any

			def begin() {
				partRequest.state = PartState.IN_TRANSIT
			}

			def duration() {
				val order = partRequest.original.order
				val part = partRequest.original.part
				if (takeParts(partRequest.original)) {
					log("Деталь " + part.name + " взята со склада");
					return 0
				// Детали с датой доставки null считаем неотгруженными, для таких случаем возвращаем разницк создания и последнего изменения заказа
				} else if (partRequest.original.hasDateOfDelivery && partRequest.original.getDeliveryInterval > 0) {
					log("Деталь " + part.name + " будет доставлена через " + partRequest.original.getDeliveryInterval +
						" дней");
					return partRequest.original.getDeliveryInterval
				// Детали с отрицательной длительностью считаем уже на складе
				} else if (partRequest.original.hasDateOfDelivery) {
					log("Деталь " + part.name + " имеет <0 длительность, считаем, что на складе");
					return 0
				} else if (order.hasRealizationInterval) {
					log("Деталь " + part.name + " будет доставлена через " + order.getRealizationInterval +
						" дней (по дате реализации заказа)");
					return order.getRealizationInterval
				}
				log("Деталь " + part.name + " будет доставлена через " + order.getModificationInterval +
					" дней (по дате изменения заказа)");
				return order.getModificationInterval
			}

			def end() {
				partRequest.state = PartState.ARRIVED
			}
		}

		rule UtilizePartRequest() {
			relevant partRequest = PartRequestType.accessible.filter[state == PartState.ARRIVED].any

			def execute() {
				val orderType = partRequest.order
				orderType.requests.remove(partRequest)
				partRequest.erase()
				if (orderType.requests.isEmpty())
					orderType.state = OrderState.FINISHED
			}
		}

		logic Model {
			activity orderProcessing = new Activity(OrderProcessing.create())
			activity utilizeOrder = new Activity(UtilizeOrder.create())
			activity partProcessing = new Activity(PartProcessing.create())
			activity utilizePartRequest = new Activity(UtilizePartRequest.create())
		}

		def init() {
			val query = data.<Order>getQuery
			val qOrder = QOrder.order
			val orderList = query.from(qOrder).fetch

			for (order : orderList) {
				OrderReceived.plan(order.getEpochDayOfCreation(), order)
			}
			log("Orders total " + orderList.size)
		}

		result fails = Result.create([orderStats.fails], new LastValueStatistics())
		result successes = Result.create([orderStats.successes], new LastValueStatistics())
		