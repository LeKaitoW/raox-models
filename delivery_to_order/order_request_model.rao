import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder

import java.util.Iterator

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider

constant terminateTime = 6000 // Время остановки минуты?
constant allowedDeliveryWaitPeriod = 4 // Допустимое время ожидания заказа, дни
constant defaultDeliveryTime = 3 // Время ожидания в днях
sequence orderRequestReceivedInterval = new Exponential(123456789, 1 / 30.0)

enum State {REQUESTERD, IN_TRANSIT, ARRIVED}

constant data = new SqlDataProvider(
	"com.mysql.jdbc.Driver",
	"jdbc:mysql://mikhailmineev.ru:3306/corpterminal?zeroDateTimeBehavior=convertToNull",
	"jpademo",
	"5xYB2e6T5Jo7ajA",
	Part,
	Order,
	PartRequest)
	
/*dataprovider corpTerminal = new SqlDataProvider("jdbc:mysql://localhost:3306/corpterminal","observer","compaq")
	.addEntity("Part")*/

type OrderIterator {
	Iterator<Order> iterator
}

type PartRequestType {
	PartRequest partRequest
	State state
}

resource orderIterator = OrderIterator.create(null)

event OrderReceived() {
	// Создание образца запроса
	var order = orderIterator.iterator.next()
	for (partRequest : order.requestedParts) {
		PartRequestType.create(partRequest, State.REQUESTERD)
	}
	
	OrderReceived.plan(currentTime + orderRequestReceivedInterval.next())
}

operation PartProcessing() {
    relevant partRequest_ = PartRequestType.accessible.filter[state == State.REQUESTERD].any

    def begin() {
        partRequest_.state = State.IN_TRANSIT
    }

    def duration() {
        return defaultDeliveryTime
    }

    def end() {
        partRequest_.state = State.ARRIVED
    }
}

logic Model {
    activity partProcessing = new Activity(PartProcessing.create())
    activity utilizeProcessed = new Activity(UtilizeProcessed.create())
}

rule UtilizeProcessed() {
    relevant partRequest_ = PartRequestType.accessible.filter[state == State.ARRIVED].any

    def execute() {
        partRequest_.erase()
    }
}

def init() {
	var query = data.getQuery()
	var order = QOrder.order
	orderIterator.iterator = query.from(order).fetch().iterator()
	OrderReceived.plan(orderRequestReceivedInterval.next())
}

def terminateCondition() {
	return currentTime >= terminateTime || !orderIterator.iterator.hasNext()
}
