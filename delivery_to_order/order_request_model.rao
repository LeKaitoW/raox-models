import domain.LocalDateAttributeConverter
import domain.Order
import domain.Part
import domain.PartRequest
import domain.QOrder
import domain.QPartRequest

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider

import java.util.ArrayList
import java.time.temporal.ChronoUnit
import java.time.LocalDate
import java.util.TreeMap
import java.util.stream.Collectors

/* Connection data */
constant driver = "com.mysql.jdbc.Driver"
constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "Observer"
constant password = "CY73-YVRE-3FT2"
constant initialBalance = 5_000_000
constant failDuration = new ArrayList<Double>
constant successfulDuration = new ArrayList<Double>
constant failPrices = new ArrayList<Long>
constant successfulPrices = new ArrayList<Long>
constant deliveries = new ArrayList<Integer>

dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest, LocalDateAttributeConverter)

type OrderStats {
	long balance
	double fillCoeff
	int fillDateForward
	DiscreteHistogram<Long> randomWaitPeriod
}

resource orderStats = OrderStats.create(initialBalance, 1, 6, null)

long getModificationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfProcessing
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getModificationInterval " + interval)
	return interval
}

long getRealizationInterval(Order order) {
	val start = order.dateOfCreation
	val end = order.dateOfRealization
	val interval = start.until(end, ChronoUnit.DAYS)
	if (interval < 0)
		throw new IllegalStateException("getRealizationInterval " + interval)
	return interval
}

long getDeliveryInterval(PartRequest partRequest) {
	val start = partRequest.order.dateOfCreation
	val end = partRequest.dateOfDelivery
	val interval = start.until(end, ChronoUnit.DAYS)
	return interval
}

long calculatePrice(OrderType orderType){
	val order = orderType.original
	var sum = 0L
	for (partRequest : order.requestedParts){
		val part = partRequest.part
		var sellprice = 0
		var count = partRequest.count
		if(part.sellingprice > 0)
			sellprice = part.sellingprice
		if(sellprice == 0 && part.clientprice > 0)
			sellprice = part.clientprice
		if(sellprice == 0 && part.retailprice > 0)
			sellprice = part.retailprice
		debug(String.format("Деталь стоит %d, %s", sellprice * count, partRequest))
		sum += sellprice * count
	}
	return sum
}

boolean canTakePartsFromWarehouse(PartRequest request) {
	return request.part.stocked >= request.count;
}

void takePartsForOrder(Order order) {
	for (PartRequest request : order.requestedParts) {
		takeParts(request)
	}
}

void takeParts(PartRequest request) {
	val part = request.part
	if (canTakePartsFromWarehouse(request)) {
		part.stocked -= request.count
	} else {
		// проверка будущей потребности, берем +1 месяц
		val startDate = request.order.dateOfCreation
		val endDate = startDate.plusMonths(1)
		val query = data.<PartRequest>getQuery
		val qpartRequest = QPartRequest.partRequest
		val partList = query.from(qpartRequest).where(
			qpartRequest.order.dateOfCreation.between(startDate, endDate).and(qpartRequest.eq(request))).fetch
			
		var futureRequirementCount = 0
		for(row : partList)
			futureRequirementCount += row.count
			
		var deliveryPrice = 0
		var supplyAmount = 0
		if (futureRequirementCount == 1) {
			// вызываем курьера, за 700 рублей
			// сбрасываем число, не мог здесь оказаться, если деталей хватало, или если требовалось > 1
			supplyAmount = 1
			deliveryPrice = 700
		} else {
			// > 1, дозаказываем детали на 6 недель
			val endDateForDelivery = startDate.plusWeeks(orderStats.fillDateForward)
			val query2 = data.<PartRequest>getQuery
			val partListToAdd = query2.from(qpartRequest).where(
				qpartRequest.order.dateOfCreation.between(startDate, endDateForDelivery).and(
					qpartRequest.part.eq(part))).fetch

			for (row : partListToAdd)
				supplyAmount += row.count
				
			supplyAmount = Math.round(supplyAmount * orderStats.fillCoeff) as int
			deliveryPrice = 1500
		}
		val price = part.purchaseprice * supplyAmount + deliveryPrice
		if(price > 300_000)
			info(String.format("Доставка за %d р. %d деталей \tБаланс: %d %s", price, supplyAmount, orderStats.balance, request))
		deliveries.add(price)
		orderStats.balance = orderStats.balance - price
		part.stocked += supplyAmount - request.count
	}
}

long duration(PartRequest request) {
	val order = request.order
	val part = request.part
	if (canTakePartsFromWarehouse(request)) {
		debug(String.format("Деталь %s взята со склада", part.name));
		return 0
	// Детали с датой доставки null считаем неотгруженными, для таких случаем возвращаем разницк создания и последнего изменения заказа
	} else if (request.dateOfDelivery !== null && getDeliveryInterval(request) >= 0) {
		debug(
			String.format("Деталь %s будет доставлена через %d дней", part.name,
				getDeliveryInterval(request)))
		return getDeliveryInterval(request)
	// Детали с отрицательной длительностью считаем уже на складе
	} else if (request.dateOfDelivery !== null) {
		debug(
			String.format("Деталь %s имеет <0 длительность, считаем, что на складе. Длительность: %d", part.name,
				getDeliveryInterval(request)));
		return 0
	} else if (order.dateOfRealization !== null) {
		debug(
			String.format("Деталь %s будет доставлена через %d дней (по дате реализации заказа)", part.name,
				getRealizationInterval(order)));
		return getRealizationInterval(order)
	}
	debug(
		String.format("Деталь %s будет доставлена через %d дней (по дате изменения заказа)", part.name,
			getModificationInterval(order)));
	return getModificationInterval(order)
}

/* Model data */
enum OrderResult {OK, FAIL, LATE}
enum OrderState {REQUESTED, PROCESSING, FINISHED}
enum Level {DEBUG, INFO}
constant logLevel = Level.INFO

type OrderType {
	Order original
	OrderState state
	OrderResult resulted
	double creationTime
	double emptyProcessDuration
}

long waitPeriod(OrderType order) {
	return orderStats.randomWaitPeriod.next()
}

/* Order logic */
event Payments() {
	orderStats.balance = orderStats.balance - 200_000
}

event OrderReceived(Order order) {
	if (order.requestedParts.isEmpty && order.dateOfRealization === null && order.dateOfProcessing === null) {
		return
	}
	if (order.solutionName == "ЗаявкаВыданаВРезерв") {
		return
	}
	OrderType.create(order, OrderState.REQUESTED, OrderResult.OK, currentTime, 0)
}

operation OrderProcessing() {
	relevant order = OrderType.accessible.filter[state == OrderState.REQUESTED].any

	def begin() {
		order.state = OrderState.PROCESSING
	}

	def duration() {
		val parts = order.original.requestedParts
		if (parts.isEmpty) { // Пустые - заказы, по которым не смогли подобрать деталь, считаются неуспешными
			order.resulted = OrderResult.FAIL
			if (order.original.dateOfRealization !== null) {
				return getRealizationInterval(order.original)
			}
			return getModificationInterval(order.original)
		}
		var duration = Long.MIN_VALUE
		for (partRequest : parts) {
			val newDuration = duration(partRequest)
			if (duration < newDuration)
				duration = newDuration
		}
		if (duration > waitPeriod(order))
			order.resulted = OrderResult.LATE
		else 
			takePartsForOrder(order.original)
		return duration
	}

	def end() {
		order.state = OrderState.FINISHED
	}
}

rule UtilizeOrder() {
	relevant order = OrderType.accessible.filter[state == OrderState.FINISHED].any

	def execute() {
		order.erase()
		switch (order.resulted) {
			case LATE: {
				val duration = currentTime - order.creationTime
				failDuration.add(duration)
			}
			case FAIL: {
				val duration = currentTime - order.creationTime
				failDuration.add(duration)
			}
			case OK: {
				val duration = currentTime - order.creationTime
				successfulDuration.add(duration)
			}
		}
		
		val price = calculatePrice(order)
		if (order.resulted == OrderResult.OK) {
			successfulPrices.add(price)
			orderStats.balance = orderStats.balance + price
		} else {
			failPrices.add(price)
		}
		debug(String.format("Заказ обработан %d р. %s\t\tБаланс: %d %s", price, order.resulted, orderStats.balance, order.original))
	}
}

logic Model {
	activity orderProcessing = new Activity(OrderProcessing.create())
	activity utilizeOrder = new Activity(UtilizeOrder.create())
}

sequence случайный_тип_клиента = new DiscreteHistogram<Long>(1234567,
    #[1L -> 7.0, 2L -> 3.0])
    
def experiments(){
	init
	val startDate = LocalDate.parse("2017-01-01")
	val endDate = LocalDate.parse("2018-01-01")
	val qOrder = QOrder.order
	
	val _query = data.<Order>getQuery
	val _orderList = _query.from(qOrder).where(qOrder.dateOfCreation.between(startDate, endDate)).orderBy(qOrder.id.asc).fetch
	
	val map = new TreeMap<Long,Pair<Double,Double>>
	for (order : _orderList) {
	if (!(order.requestedParts.isEmpty && order.dateOfRealization === null && order.dateOfProcessing === null)) {
			val ok = order.dateOfRealization !== null
			if (ok) {
				val interval = order.dateOfCreation.until(order.dateOfRealization, ChronoUnit.DAYS)
				val results = map.computeIfAbsent(interval, [k|(0.0d -> 0.0d)])
				map.put(interval, results.key + 1 -> results.value)
			} else {
				val interval = order.dateOfCreation.until(order.dateOfProcessing, ChronoUnit.DAYS)
				val results = map.computeIfAbsent(interval, [k|(0.0d -> 0.0d)])
				map.put(interval, results.key -> results.value + 1)
			}
		}
	}
	val seq = map.entrySet().stream().filter([e|e.key <= 30]).map([e |
		e.key -> (e.value.key / e.value.value)
	]).collect(Collectors.<Pair<Long, ? extends Number>>toList())
	debug("Using this sequence for order wait: " + seq.toString)
	orderStats.randomWaitPeriod = new DiscreteHistogram<Long>(1234567L, seq)
	
	orderStats.fillCoeff = 0.8
	do {
		orderStats.fillCoeff = orderStats.fillCoeff + 0.2
		orderStats.balance = initialBalance
		orderStats.randomWaitPeriod = new DiscreteHistogram<Long>(1234567L, seq)
		failDuration.clear
		successfulDuration.clear
		failPrices.clear
		successfulPrices.clear
		deliveries.clear
		data.clear
		
		info(String.format("Эксперимент. Коэффициент докупки %f", orderStats.fillCoeff))

		val query = data.<Order>getQuery
		val orderList = query.from(qOrder).where(qOrder.dateOfCreation.between(startDate, endDate)).orderBy(qOrder.id.asc).fetch
		for (order : orderList) {
			OrderReceived.plan(order.getEpochDayOfCreation(), order)
		}
		var payDate = startDate
		while (payDate.isBefore(endDate)) {
			Payments.plan(payDate.toEpochDay())
			payDate = payDate.plusMonths(1)
		}
		start
	} while (orderStats.fillCoeff < 2)
}

def terminateCondition() {
    return orderStats.balance <= 0
}

def init() {
}

def finish() {
	val successes = successfulDuration.size
	val fails = failDuration.size
	val percentage = if((successes + fails) == 0) 0 else successes * 100 /
			(successes + fails)
	log(
		String.format("Result: \t\tOrders: %d/%d Successful percentage: %d%%", successes,
			successes + fails,
			percentage))
	val failResults = failDuration.stream.mapToDouble([f | f]).summaryStatistics
	log(
		String.format("Fail duration: \tAverage: %f\tMax: %f\tMin: %f", failResults.getAverage, failResults.getMax,
			failResults.getMin))
	val successfulResults = successfulDuration.stream.mapToDouble([f | f]).summaryStatistics
	log(
		String.format("Ok duration: \tAverage: %f\tMax: %f\tMin: %f", successfulResults.getAverage,
			successfulResults.getMax, successfulResults.
				getMin))
	val failPriceResults = failPrices.stream.mapToLong([f | f]).summaryStatistics
	log(
		String.format("Fail price: \tAverage: %f\tMax: %d\tMin: %d", failPriceResults.getAverage,
			failPriceResults.getMax,
			failPriceResults.
				getMin))
	val successPriceResults = successfulPrices.stream.mapToLong([f | f]).summaryStatistics
	log(
		String.format("Ok prive: \t\tAverage: %f\tMax: %d\tMin: %d", successPriceResults.getAverage,
			successPriceResults.getMax, successPriceResults.getMin))
	val deliveryResults = deliveries.stream.mapToInt([f | f]).summaryStatistics
	log(
		String.format("Deliveries: \t\tSum: %d", deliveryResults.getSum))
	
	log(String.format("Balance: \t\tLast: %d \tDelta: %d", orderStats.balance, (orderStats.balance - initialBalance)))
}

void info(String text){
	if (logLevel.ordinal <= Level.INFO.ordinal)
		log(Level.INFO + "\t" + text)
}

void debug(String text){
	if (logLevel.ordinal <= Level.DEBUG.ordinal)
		log(Level.DEBUG + "\t" + text)
}
