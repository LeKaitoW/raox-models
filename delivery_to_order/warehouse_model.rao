import domain.Order
import domain.Part
import domain.PartRequest
import domain.QPart

import java.util.Iterator

import ru.bmstu.rk9.rao.lib.persistence.SqlDataProvider
import java.util.ArrayList

/* Connection data */

constant driver = "com.mysql.jdbc.Driver"

constant url = "jdbc:mysql://localhost:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
constant username = "observer"
constant password = "compaq"

//constant url = "jdbc:mysql://mikhailmineev.ru:3306/corpterminal?zeroDateTimeBehavior=convertToNull"
//constant username = "jpademo"
//constant password = "5xYB2e6T5Jo7ajA"

dataprovider data = new SqlDataProvider(driver, url, username, password, Part, Order, PartRequest)
cursor parts = new ArrayList<Part>().iterator()

constant deliveryPrice = 5_000_00 // В копейках
constant deliveryAmount = 200 // В штуках
constant itemPrice = 1_000_00 // В копейках
constant defaultDeliveryTime = 3 // Время ожидания в днях
constant terminateTime = 6000 // Время остановки в мс
sequence itemReceivedInterval = new Exponential(123456789, 1 / 30.0)
 
type PartType {
	Part part
	int totalPrice
}

type Parts {
	Iterator<Part> iterator
}

event ItemReceived() {
	val part = parts.next()
	val price = calculatePrice(part)
	PartType.create(part, price)
	ItemReceived.plan(currentTime + itemReceivedInterval.next())
}

def init() {
	val query = data.getQuery()
	val part = QPart.part
	parts = query.from(part).fetch().iterator()
	ItemReceived.plan(itemReceivedInterval.next())
}

def terminateCondition() {
	return currentTime >= 6000 || !parts.hasNext()
}

int calculatePrice(Part part){
	deliveryPrice / deliveryAmount + part.purchaseprice
}
