import java.util.ArrayList

constant cities = 10;
constant width = 20; 
constant hight = 20;

constant populationAmount = 4;
constant mutationAmount = 2;
constant gensAmount = cities - (cities % 2);
constant gensToMutate = Math.floor(gensAmount*0.5);
constant crossbreedAmount = populationAmount - mutationAmount;
constant crossbreedingPoints = 3;

enum visited {Y,N}
enum mutate {Y,N}
enum crossbreed {Y,N}
	
type City {
	visited visit;
	double num;
	double x;
	double y;
}

type SwapsRule{
	ArrayList<Double> swaps;
}

type WayOfVoyager{
	ArrayList<Double> way;
}

type OneOfKind{
	ArrayList<Double> swaps;
	ArrayList<Double> way;
	double wayLength;
	double generation;
	mutate mutated;
	crossbreed crossbreeded;
}

sequence koordinatesWidth = new Uniform(987654321,0,width);
sequence koordinatesHight = new Uniform(123456789,0,hight);
sequence citiesSqnc = new Uniform(123456,1,cities+1);
sequence gensSqnc = new Uniform(33425454,0,gensAmount);

resource wayZh = WayOfVoyager.create(new ArrayList<Double>(cities));
resource wayR = WayOfVoyager.create(new ArrayList<Double>(cities));

set init(){	
	for (var i = 0; i < cities; i++) {
		City.create(visited.N,i,koordinatesWidth.next(),koordinatesHight.next());
	}	
	ZhadniiAlgoritm.plan(1,wayZh);
	RandomWay.plan(2,wayR);
	KindCreation.plan(3);
}

	

event ZhadniiAlgoritm (WayOfVoyager wayVoyager){	
	var gorod1 = City.all.filter[num == 1].any;
	wayVoyager.way.add(gorod1.num);
	gorod1.visit = visited.Y; 
	
	for (var City gorod2; City.all.filter[visit == visited.N].size() > 0 ; ){
		
		val X = gorod1.x;
		val Y = gorod1.y;
		
	 	gorod2 = City.all.filter[visit == visited.N].minBySafe[distanceBetween(X,Y,x,y)];
	 
	 	wayVoyager.way.add(gorod2.num);
	 	
	 	gorod2.visit = visited.Y;
	 	gorod1 = gorod2;
	}
	Reset.plan(currentTime)
}

event RandomWay (WayOfVoyager wayR){	
	var gorod1 = City.all.filter[num == 1].any;
	
	wayR.way.add(gorod1.num);
	gorod1.visit = visited.Y; 
	
	for (var City gorod2; City.all.filter[visit == visited.N].size() > 0 ; ){
	 	gorod2 = City.all.filter[visit == visited.N].any;	 
	 	wayR.way.add(gorod2.num);	 	
	 	gorod2.visit = visited.Y;
	 	gorod1 = gorod2;
	}
	Reset.plan(currentTime)
}

event KindCreation(){
	for (var i = 0; i < populationAmount; i++){
		var Odin = OneOfKind.create(new ArrayList <Double>(cities),new ArrayList <Double>(cities),0,0,mutate.N,crossbreed.N)
		for (var j = 0; j < gensAmount; j++){
			Odin.swaps.add(Math.floor(citiesSqnc.next()));
		}
		Odin.way = convertToWay(Odin.swaps);
		Odin.wayLength = getWayLength(Odin.way);
	}
}

event Evolution(){
	Crossbreeding.plan(currentTime);
	Mutation.plan(currentTime);
	Competition.plan(currentTime);
  	ResetKind.plan(currentTime);
	Evolution.plan(currentTime+1);
}

event Crossbreeding(){
	for (var i=0; i < Math.floor(crossbreedAmount/2) && OneOfKind.all.filter[mutated == mutate.N].filter[crossbreeded == crossbreed.N].size()>2; i++){
		var Adam = OneOfKind.all.filter[mutated == mutate.N].filter[crossbreeded == crossbreed.N].any;
		var Eve = OneOfKind.all.filter[mutated == mutate.N].filter[crossbreeded == crossbreed.N].any;
			
		var Avel = OneOfKind.create(new ArrayList <Double>(cities),new ArrayList <Double>(cities),0,0,mutate.N,crossbreed.Y);
		var Kain = OneOfKind.create(new ArrayList <Double>(cities),new ArrayList <Double>(cities),0,0,mutate.N,crossbreed.Y);
			
		for(var j = 0; j < crossbreedingPoints; j++ ){
			var Point = Math.floor(gensSqnc.next());
			for (var k = 0; k < Point; k++ ){
				Avel.swaps.add(Adam.swaps.get(k));
				Kain.swaps.add(Eve.swaps.get(k));
			}
			for (var int k = intValue(Point); k < gensAmount; k++){ //тип данных k меняется без intValue()
				Avel.swaps.add(Eve.swaps.get(k))
				Kain.swaps.add(Adam.swaps.get(k));
			}
		}
		Avel.generation = Adam.generation+1;
		Avel.way = convertToWay(Avel.swaps);
		Avel.wayLength = getWayLength(Avel.way);
		
		Kain.generation = Eve.generation+1;
		Kain.way = convertToWay(Avel.swaps);
		Kain.wayLength = getWayLength(Avel.way);
	}
}

event Mutation(){
		for (var i=0; i < mutationAmount && OneOfKind.all.filter[crossbreeded == crossbreed.N].filter[mutated == mutate.N].size()>0;i++){
			var Grip = OneOfKind.all.filter[crossbreeded == crossbreed.N].filter[mutated == mutate.N].any;
			var Ebola = OneOfKind.create(new ArrayList <Double>(cities),new ArrayList <Double>(cities),0,0,mutate.N,crossbreed.N);
			Ebola.swaps = Grip.swaps;
			Ebola.generation = Grip.generation+1;
			for (var j = 0; j < gensToMutate;j++){
				Ebola.swaps = changeGenTo(Ebola.swaps, Math.floor(gensSqnc.next()),Math.floor(citiesSqnc.next()));
			}
			Ebola.mutated = mutate.Y;
			Ebola.way = convertToWay(Ebola.swaps);
			Ebola.wayLength = getWayLength(Ebola.way);
		}
}

event Competition(){
	for( ;OneOfKind.all.size() > populationAmount; ){  
		var Kenny = OneOfKind.all.maxBySafe[wayLength];
		Kenny.erase();
	}
	ResetKind.plan(currentTime);
}

event ResetKind(){
	for(;OneOfKind.all.filter[mutated == mutate.Y].size()>0;){
		var winner = OneOfKind.all.filter[mutated == mutate.Y].any
		winner.mutated = mutate.N;
	}
	for(;OneOfKind.all.filter[crossbreeded == crossbreed.Y].size()>0;){
		var winner = OneOfKind.all.filter[mutated == mutate.Y].any
		winner.crossbreeded = crossbreed.N;
	}
}

ArrayList<Double> changeGenTo(ArrayList<Double> swaps, Double genN, Double changeTo){
	var int N = intValue(genN);
	if (N >= swaps.size())
		return swaps;
	var ArrayList<Double> tArray = new ArrayList<Double>(swaps.size()-(N+1));
	swaps.remove(genN);
	for(;swaps.size() > N+1;){
		tArray.add(swaps.remove(N));
	}
	swaps.add(changeTo);
	swaps.addAll(tArray);
	return swaps;
}

ArrayList<Double> convertToWay(ArrayList<Double> swaps){
	var ArrayList<Double> way = new ArrayList<Double>();
	for (var i = 0; i < cities; i++){
		way.add(Double.valueOf(i));
	}
	for (var i = 0; i < swaps.size(); i+=2){
		way = SwapPoints(way,i,i+1);
	}
	return way;
}

ArrayList<Double> SwapPoints(ArrayList<Double> way, int p1, int p2){
	if (p1==p2)
		return way;
	var int n;	
	var int m;
	if (p1<p2){
		n = p1;
		m = p2;
	}
	else
	{
		n = p2;
		m = p1;
	}
	var Double temp = way.remove(n);
	var ArrayList<Double> tArray = new ArrayList<Double>(way.size() - (n + 1))
	for (var i = n+1; i < m; i++){
		tArray.add(way.remove(n));
	}
	way.add(way.remove(n));
	tArray.add(temp);
	for (;way.size() > n;){
		tArray.add(way.remove(n));
	}
	way.addAll(tArray);
	return way;
}

int intValue(Double D){
	var double d = Double.valueOf(D);
	var int i = d as int ;
	return i
}

event Reset(){
	for (var City gorod; City.all.filter[visit == visited.Y].size() > 0 ; ){
		gorod = City.all.filter[visit == visited.Y].any
		gorod.visit = visited.N
	}
}

double distanceBetween(double x1, double y1, double x2, double y2){
	val y_diff = Math.abs(y1 - y2)
    val x_diff = Math.abs(x1 - x2)
	return Math.sqrt(y_diff * y_diff + x_diff * x_diff)
}

double getWayLength(ArrayList<Double> way) {
    if (way.size() == 0)
        return 0;
    var gorod0 = City.all.filter[num == way.get(0)].any;      
 	var gorod1 = gorod0;	
    var double length = 0;   
    
 	for (var i = 1; i < way.size(); i++){
 		val ii = i;
 		var gorod2 = City.all.filter[num == way.get(ii)].any; 
 		length = length+distanceBetween(gorod1.x,gorod1.y,gorod2.x,gorod2.y);
 		gorod1 = gorod2;
 	}
 	length = length+distanceBetween(gorod1.x,gorod1.y,gorod0.x,gorod0.y);
    return length;
}
 
result LengthOfZh = new Value([getWayLength(wayZh.way)])
result LengthOfR = new Value([getWayLength(wayR.way)])
