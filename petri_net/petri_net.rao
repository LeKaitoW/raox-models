import java.util.Arrays

type Позиция {
	int количество_маркеров;
	}

type Переход {
	Позиция[] входы;
	Позиция[] выходы;
	int время_перехода;
}

resource робот_свободен = Позиция.create(1);

resource наличие_заготовки_в_накопителе = Позиция.create(0);
resource заготовка_установлена_на_первом_станке = Позиция.create(0);
resource заготовка_обработана_на_первом_станке = Позиция.create(0);
resource первый_станок_свободен = Позиция.create(1);

resource заготовка_установлена_на_втором_станке = Позиция.create(0);
resource заготовка_обработана_на_втором_станке = Позиция.create(0);
resource второй_станок_свободен = Позиция.create(1);
resource наличие_обработанной_заготовки_в_накопителе = Позиция.create(0);

resource загрузка_первого_станка = Переход.create(Arrays.asList(робот_свободен, первый_станок_свободен, наличие_заготовки_в_накопителе),
	Arrays.asList(робот_свободен, заготовка_установлена_на_первом_станке), 5);
resource обработка_на_первом_станке = Переход.create(Arrays.asList(заготовка_установлена_на_первом_станке), 
	Arrays.asList(заготовка_обработана_на_первом_станке), 10);
resource переустановка = Переход.create(Arrays.asList(робот_свободен, заготовка_обработана_на_первом_станке, второй_станок_свободен), 
	Arrays.asList(робот_свободен, заготовка_установлена_на_втором_станке, первый_станок_свободен), 3);
resource обработка_на_втором_станке = Переход.create(Arrays.asList(заготовка_установлена_на_втором_станке), 
	Arrays.asList(заготовка_обработана_на_втором_станке), 15);
resource разгрузка_второго_станка = Переход.create(Arrays.asList(заготовка_обработана_на_втором_станке, робот_свободен), 
	Arrays.asList(робот_свободен, наличие_обработанной_заготовки_в_накопителе, второй_станок_свободен), 4);

boolean проверка_массива(Позиция[] массив){
	var j=0;
	for (var i = 0; i < массив.length; i++) {
		if (массив.get(i).количество_маркеров > 0)
			j = j+1;
	}
	if (j == массив.length){
		return true;
	}
	else{
		return false;
	}
}

event Событие_прихода_заготовки(){
	Событие_прихода_заготовки.plan(currentTime + интервал_прихода.next());
	наличие_заготовки_в_накопителе.количество_маркеров = наличие_заготовки_в_накопителе.количество_маркеров + 1;
}

operation Работа_сети_Петри() {
	
    relevant _переход = Переход.accessible.filter[проверка_массива(входы)].any;

    	def begin() {
        	for (var i = 0; i < _переход.входы.length; i++) {
				_переход.входы.get(i).количество_маркеров = _переход.входы.get(i).количество_маркеров - 1;
			}
    	}

    	def duration() {
        return _переход.время_перехода;
    	}

    	def end() {
			for (var i = 0; i < _переход.выходы.length; i++) {
				_переход.выходы.get(i).количество_маркеров = _переход.выходы.get(i).количество_маркеров + 1;
			}
    	}
}

sequence интервал_прихода = new Exponential(123456789, 1/30.0);

logic Модель {
    activity сеть_Петри = new Activity(Работа_сети_Петри.create());
}

def init() {
    Событие_прихода_заготовки.plan(интервал_прихода.next());
}

def terminateCondition() {
    return наличие_обработанной_заготовки_в_накопителе.количество_маркеров == 10;
}

frame Петри {
	def init() {
		background = new Background(1300, 700, RaoColor.WHITE)
	}

	def draw() {
		drawLine(0, 540, 1300, 540, RaoColor.BLACK)
		drawLine(0, 560, 1300, 560, RaoColor.BLACK)
		drawImage("img/stanok1.png", 200, 245)
		drawImage("img/stanok2.png", 700, 222)
		drawRectangle(1000, 270, 200, 100, RaoColor.WHITE, RaoColor.BLACK)
		
		drawImage("img/nakopitel.png", 70, 20)
		drawImage("img/robot1.png", 37, 445)
		drawImage("img/robot5.png", 966, 337)
		drawCircle(96, 355, 19, RaoColor.BLACK, RaoColor.BLACK)
		drawLine(0, 355, 1300, 355, RaoColor.BLACK)
	}
}